{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png","path":"images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png","modified":0,"renderable":0},{"_id":"source/images/M3ECbky79odXDkxrPwkc4hO4n3d.png","path":"images/M3ECbky79odXDkxrPwkc4hO4n3d.png","modified":0,"renderable":0},{"_id":"source/images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png","path":"images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png","modified":0,"renderable":0},{"_id":"source/images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png","path":"images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/0.jpg","path":"img/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/2.jpg","path":"img/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/1.jpg","path":"img/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/3.jpg","path":"img/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/4.jpg","path":"img/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/5.jpg","path":"img/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/6.jpg","path":"img/banner/6.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"be2f1adeea1e1595ecd5526a52f585f52a24d2e1","modified":1705568904030},{"_id":"source/_posts/2023七月到九月总结.md","hash":"f6aa9d9f1221eca09444846c05777287724a637a","modified":1705570786306},{"_id":"source/_posts/2023年度总结.md","hash":"c3bf790b838fbd4a5f56a038fd4f3cc2126ee98c","modified":1705570786305},{"_id":"source/_posts/Handler Android 消息机制.md","hash":"acb7a273f790b099e2e65bcc682c252f31ef21dd","modified":1705570786307},{"_id":"source/_posts/virtual-memory-for-user-applications.md","hash":"d8f34d66b02c633b2c46bb5bf46630bbf1f70191","modified":1705570786308},{"_id":"source/_posts/xv6-fs.md","hash":"0c3b7059a4b473d357a92885e71e2d3f285565c4","modified":1705570786309},{"_id":"source/_posts/博客写作部署分离实践.md","hash":"c567955e0c2688d4b3e7922426b664cc7329c367","modified":1705570786304},{"_id":"source/_posts/周报.md","hash":"6425e899e787d4e0330081fee703824f4f540747","modified":1705570812504},{"_id":"source/_posts/新的开始.md","hash":"56ba6538f0c15005b09449736e8eb22b26b25d2a","modified":1705570786305},{"_id":"source/_posts/解决 bear 在 MacOS 中生成空 compile_commands.json.md","hash":"b46b24a406b415035e5cf9e945f26a819730b057","modified":1705570786306},{"_id":"source/images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png","hash":"7d574c6137244d1a001480f7b927278a1bae8f88","modified":1705570530577},{"_id":"source/_data/link.yml","hash":"82bd6744e3cba978fd5af21ddd405f88de6d51fb","modified":1687881057924},{"_id":"source/categories/index.md","hash":"824cb6c9d6497d4b1ecf29c767c5a575d3118da6","modified":1687880440169},{"_id":"source/link/index.md","hash":"03a4dc40cc4e2b8ef615929a5881879eb961df5c","modified":1687880742437},{"_id":"source/tags/index.md","hash":"1cd06a0b35132ab779fcd5a1594720fde1a882c3","modified":1687880401205},{"_id":"source/images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png","hash":"ccecc4f5dbdb32a51374a1e82df8a466ac00edda","modified":1705570530579},{"_id":"source/images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png","hash":"bbe3b87a2ddbe9c83f5e36b513d1c6fd81feec7c","modified":1705570530581},{"_id":"source/images/M3ECbky79odXDkxrPwkc4hO4n3d.png","hash":"a83a6090a623063416e9e3c5ab0a5b9d579a5cf7","modified":1705570530580},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1687874786642},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1687874786642},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1687874786635},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1687874786635},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1687874786635},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1687874786635},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1687874786635},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1687874786642},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1687874786642},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1687874786642},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1687874786642},{"_id":"themes/butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1687874786635},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1687874786635},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1687874786635},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1687874786635},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1687874786635},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1687874786635},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1687874786635},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1687874786634},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1687874786636},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1687874786642},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1687874786642},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1687874786642},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1687874786642},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1687874786642},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1687874786642},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1687874786642},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1687874786642},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1687874786643},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1687874786643},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1687874786643},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1687874786643},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1687874786642},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1687874786643},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1687874786635},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1687874786643},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1687874786634},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1687874786643},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1687874786643},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1687874786647},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1687874786646},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1687874786643},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1687874786647},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1687874786647},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1687874786648},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1687874786642},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1687874786648},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1687874786647},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1687874786636},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1687874786647},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1687874786636},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1687874786637},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1687874786642},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1687874786642},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1687874786640},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1687874786644},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1687874786645},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1687874786645},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1687874786645},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1687874786644},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1687874786643},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1687874786645},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1687874786645},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1687874786644},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1687874786645},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1687874786645},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1687874786645},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1687874786645},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1687874786644},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1687874786645},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1687874786645},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1687874786645},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1687874786645},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1687874786646},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1687874786645},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1687874786646},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1687874786646},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1687874786646},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1687874786647},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1687874786646},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1687874786646},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1687874786647},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1687874786638},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1687874786639},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1687874786641},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1687874786640},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1687874786640},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1687874786644},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1687874786644},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1687874786644},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1687874786644},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1687874786644},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"7f3944f24beb7f74c0002f9bd66bb69160092ebd","modified":1687878417000},{"_id":"themes/butterfly/source/img/banner/3.jpg","hash":"e90bf089aefe9335533e3100b8884efbf5afe4f1","modified":1687878994310},{"_id":"themes/butterfly/source/img/banner/1.jpg","hash":"120e44d82a71a53753d341b40d296d88a988b6a4","modified":1687878994307},{"_id":"themes/butterfly/source/img/banner/0.jpg","hash":"533c654621b62b59e5e2bb34e1d395d2df1ac9d0","modified":1687878994306},{"_id":"themes/butterfly/source/img/banner/4.jpg","hash":"3550f27acfacd334a55ee3a8ef4d55a364071347","modified":1687878994312},{"_id":"themes/butterfly/source/img/banner/5.jpg","hash":"ed1bdfb61dae0cc949fc0bb15a057b7aa957ec92","modified":1687878994314},{"_id":"themes/butterfly/source/img/banner/2.jpg","hash":"8148fbb013e119e345c01bfcd3b95a8bbfb28339","modified":1687878994309},{"_id":"themes/butterfly/source/img/banner/6.jpg","hash":"cd8f514ad8db1b74d541f83b987b2f17f8e1211c","modified":1687878994317},{"_id":"public/categories/index.html","hash":"0d92634d55ae9df799b680b6bdf935183c0b2ddb","modified":1705570961134},{"_id":"public/link/index.html","hash":"cfc56be111524699c4581bef8f533e022e251bcf","modified":1705570961134},{"_id":"public/tags/index.html","hash":"4787a6747586dbad15a9c0a6e33d1a46e061d1ff","modified":1705570961134},{"_id":"public/images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png","hash":"7d574c6137244d1a001480f7b927278a1bae8f88","modified":1705570607771},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1705570607771},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1705570607771},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1705570607771},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1705570607771},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1705570607771},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1705570607771},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1705570607771},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1705570607771},{"_id":"public/css/index.css","hash":"2144e07cfda26094423f63931dfc9bf9a5d1c0ce","modified":1705570607771},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1705570607771},{"_id":"public/img/avatar.jpg","hash":"7f3944f24beb7f74c0002f9bd66bb69160092ebd","modified":1705570607771},{"_id":"public/images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png","hash":"ccecc4f5dbdb32a51374a1e82df8a466ac00edda","modified":1705570607771},{"_id":"public/images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png","hash":"bbe3b87a2ddbe9c83f5e36b513d1c6fd81feec7c","modified":1705570607771},{"_id":"public/images/M3ECbky79odXDkxrPwkc4hO4n3d.png","hash":"a83a6090a623063416e9e3c5ab0a5b9d579a5cf7","modified":1705570607771},{"_id":"public/img/banner/3.jpg","hash":"e90bf089aefe9335533e3100b8884efbf5afe4f1","modified":1705570607771},{"_id":"public/img/banner/0.jpg","hash":"533c654621b62b59e5e2bb34e1d395d2df1ac9d0","modified":1705570607771},{"_id":"public/img/banner/1.jpg","hash":"120e44d82a71a53753d341b40d296d88a988b6a4","modified":1705570607771},{"_id":"public/img/banner/4.jpg","hash":"3550f27acfacd334a55ee3a8ef4d55a364071347","modified":1705570607771},{"_id":"public/img/banner/5.jpg","hash":"ed1bdfb61dae0cc949fc0bb15a057b7aa957ec92","modified":1705570607771},{"_id":"public/img/banner/2.jpg","hash":"8148fbb013e119e345c01bfcd3b95a8bbfb28339","modified":1705570607771},{"_id":"public/img/banner/6.jpg","hash":"cd8f514ad8db1b74d541f83b987b2f17f8e1211c","modified":1705570607771},{"_id":"public/atom.xml","hash":"1d415cf90929e1101011642665681fb131ebaf9f","modified":1705570853952},{"_id":"public/2023/12/31/Ehapd5iqkom3e3xScJUcxPB7nfe/index.html","hash":"37cb79d30b41ebce7b1002456aa247caeca0be1a","modified":1705570853952},{"_id":"public/2023/12/25/FashdhbmXovCtwxNwgHckhrunRt/index.html","hash":"ef316a04047dc84042baaa87c1a0185459cbc5a2","modified":1705570853952},{"_id":"public/2023/10/21/URYldeyG7okwIlxnz6lcVpvHnqE/index.html","hash":"79d5e0e5c0c26cd51cd62209fc68cb8f8820f1b3","modified":1705570853952},{"_id":"public/2024/01/18/GcC9d15VKoMKpixcYB5cPntunsf/index.html","hash":"d0d0726db2d8aae7a69c7472343797f2c10de85d","modified":1705570853952},{"_id":"public/2023/10/20/Ro5td2HZloi6YzxPcKrc9aHbn9d/index.html","hash":"16b7953eaf603e47919d8360331e2be5714df006","modified":1705570853952},{"_id":"public/2023/10/17/RLSwdlgCRo68xTxoNn6caCU1nRh/index.html","hash":"e4b64727cb5374bc106ffdc75528caa4acc9b4b1","modified":1705570853952},{"_id":"public/2023/10/07/LTj7d5ZKsoQ3hRxaA9Acn3WAnUg/index.html","hash":"40324ec80e4e9fb3783ac7a3fda40741f42a1cb6","modified":1705570853952},{"_id":"public/2023/07/04/N8Ald4KgDobdVPxjhhHc76zRnVg/index.html","hash":"e24fc7a2548db24404781143637f39daf1f6e474","modified":1705570853952},{"_id":"public/2023/06/28/VKtzd4IhRo6MwPxfJuDcow4gnwb/index.html","hash":"849816b54c15ddf918e332ee3fd5ef7e0175f138","modified":1705570853952},{"_id":"public/archives/index.html","hash":"91b90d6fa4b986ca51766cc25adab24f822fc4cb","modified":1705570961134},{"_id":"public/archives/2023/index.html","hash":"d23261e9046581d99d2ec735aae680093e313c2b","modified":1705570961134},{"_id":"public/archives/2023/06/index.html","hash":"d48692b65722731f04d56d86bc0f8cd48f399e95","modified":1705570961134},{"_id":"public/archives/2023/07/index.html","hash":"352e7f8d7bcec7cdbe9ef0fe5005e7d7548e9ed2","modified":1705570961134},{"_id":"public/archives/2023/12/index.html","hash":"4a42519d5ad0fbb585c2825fefba0b93a99f2711","modified":1705570961134},{"_id":"public/archives/2023/10/index.html","hash":"02f2190abc092be8f31ebd73f4104946cfa7b656","modified":1705570961134},{"_id":"public/archives/2024/index.html","hash":"3d3380e756cd990fffc0dc34bbde02f252d7cef4","modified":1705570961134},{"_id":"public/archives/2024/01/index.html","hash":"266b0a4d5564c50be342a35d61ad7c1dbd101354","modified":1705570961134},{"_id":"public/index.html","hash":"12d72d392ba5cb444063c2bd77f18c7ad43ee00a","modified":1705570961134},{"_id":"public/categories/笔记/index.html","hash":"ab40c1d0e2d235c0436d093e2f1c44a7eb65542d","modified":1705570961134},{"_id":"public/tags/总结/index.html","hash":"45181db76fd5345878a4cc7e8ee514be67379f33","modified":1705570961134},{"_id":"public/tags/年度总结/index.html","hash":"6e14515ed1a348921698c25a4dd9b73ab56e10bf","modified":1705570961134},{"_id":"public/tags/随笔/index.html","hash":"981bd8856d9f40b3e20c0bce3e6a1e5811a252fe","modified":1705570961134},{"_id":"public/tags/android/index.html","hash":"992b0253249797c309a9db02670014235d3fc37f","modified":1705570961134},{"_id":"public/tags/八股/index.html","hash":"72763832f546c16c3edc15f8ad57a4e7425801a3","modified":1705570961134},{"_id":"public/tags/xv6/index.html","hash":"7b6e6caed2c79333a5071d8b74a99c7936411865","modified":1705570961134},{"_id":"public/tags/公开课/index.html","hash":"613ea5b15ba94faa5467075442dd0409250988d2","modified":1705570961134},{"_id":"public/tags/MIT6-s081/index.html","hash":"e34bc8ff4195bf2883fffde116c2502967bf7d99","modified":1705570961134},{"_id":"public/tags/操作系统/index.html","hash":"940ddb0588c2141ec14080b61f8c6fbb478798b9","modified":1705570961134},{"_id":"public/tags/虚拟内存/index.html","hash":"79bc10c84a7559db235e991d48ef35f81c2a5583","modified":1705570961134},{"_id":"public/tags/File-System/index.html","hash":"131ad15a18b86ac11a14162dff0ae32d2a36a7a2","modified":1705570961134},{"_id":"public/tags/周报/index.html","hash":"9f2dfd38e9505503bf9ac991d5895c90b6b13ada","modified":1705570961134},{"_id":"public/tags/闲聊/index.html","hash":"0cff6daecdfba01e3607fa7f1cc6166fc45e4b76","modified":1705570961134},{"_id":"public/tags/编译/index.html","hash":"6544aa536aa13c68d005e8bf1d08b06c5624a67b","modified":1705570961134}],"Category":[{"name":"笔记","_id":"clrj0ulld0007fbsbdles120h"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}],"Page":[{"title":"categories","date":"2023-06-27T15:40:17.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-06-27 23:40:17\ntype: \"categories\"\n---\n","updated":"2023-06-27T15:40:40.169Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clrj0pbmn0000j0sbfr6tbcfz","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"link","date":"2023-06-27T15:40:59.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-06-27 23:40:59\ntype: \"link\"\n---\n","updated":"2023-06-27T15:45:42.437Z","path":"link/index.html","comments":1,"layout":"page","_id":"clrj0pbmp0003j0sban0037r0","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-06-27T15:39:23.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-06-27 23:39:23\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2023-06-27T15:40:01.205Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clrj0pbmq0005j0sbaun5d86m","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"2023七月到九月总结","urlname":"LTj7d5ZKsoQ3hRxaA9Acn3WAnUg","date":"2023-10-07T14:19:19.000Z","updated":"2024-01-18T09:11:20.000Z","_content":"# **2023.7～9月总结**\n\n\n从北京回来了，实习基本算告一段落了。至少线下实习告一段落了，能不能继续线上还得等结论。借此机会把 2023.7 ～ 9 月做的事情总结一下：\n\n\n## **7月**\n\n\n原本计划暑假里好好的把 xv6 给刷了，但是学长突然给了我快手实习的内推，于是暂时搁置了 cs 的学习，全心全意准备面试。一面自我感觉还算可以，但快手那边似乎是因为 hc 的问题迟迟不肯安排二面，鸽了我很长一段时间。这段时间最开始我是在准备面试的，然而等了好几天还没收到二面消息就重启了 xv6 的学习，记得是一口气做到了 traps lab，然后收到了快手的拒信。\n\n\n\n收到拒信之后本着一不做二不休的原则又在 boss 直聘上海投，然而只收到了两家公司的面试邀约：禾多科技，字节跳动（抖音开放平台）。\n\n\n\n禾多科技一面只问了20分钟，都是非常基础非常简单的问题，二面直接不问了，直接跟我介绍公司业务（做自动驾驶），但是因为只是随便投来练手的小厂，给的实习工资也不够我在北京生活，就拒了。\n\n\n\n抖音开放平台面试问得比较有水平，可惜我算法苦手，而面试官又比较看重算法这一块，好死不死一面二面的算法题一道都没有做出来，当然是挂了。问了他们的业务，似乎是做抖音小程序的开放 api。\n\n\n## **8月**\n\n\n因为没有找到实习，跟着父母一起去贵州旅游放松一下。这次去贵州旅游的体验确实很不错，印象最深刻的是韭菜坪上的一大片紫色野生韭菜花，非常的漂亮。\n\n\n\n实习的事情在旅行的中途迎来了转机。快手的hr又找上我，告诉我被挂掉的原因是当时没有 hc 了，现在又有 hc 了，如果我还愿意来的话可以直接给我安排二面。而二面的面试官（也就是我后来的 leader）因为急着用人，面试也放了不少水。于是虽然晚了些，我在 8 月 17 号正式入职了快手。\n\n\n\n不得不说那段时间我们部门确实是缺人，我在入职后只熟悉了两天代码便开始做第一个需求，mentor 忙得根本顾不上我，我遇上了问题大多数时候都是问学长（如果没有学长在的话我根本不知道怎么度过实习最开始那段时光）。实习两周之后，我基本熟悉互联网大厂产品的开发流程，并且感觉自己解决眼前的问题的能力有了长足的进步。\n\n\n\n这段时间的实习生活过得很充实，很快乐。不用烦恼学校的事情，还有两位学长陪着。然而基本抽不出时间学 xv6，只在周末的时候完成了两个 lab。\n\n\n## **9月**\n\n\n9月份学长们实习答辩完返校了，有一段时间都是我自己一个人在快手实习。没有了学长们的陪伴，实习生活确实变得乏味了些。然后就是处理一系列学校的破事，原本就打算瞒着辅导员请代课，结果父母不放心给辅导员打了电话。原本辅导员也不想管这个事情，奈何这学期换了个辅导员，这个辅导员是七月份新入职的，俗话说新官上任三把火，她这火直接烧我头上了。\n\n\n\n本来那段时间工作就忙，再加上每天晚上要处理学校的破事，过得非常的痛苦。本来是想至少拖到十月末再回家，但是正巧跟学长们同租的房子也到期了，根本找不到能短租一个月的房子，再加上父母和学校那边给的压力，最后还是决定国庆节就回来。\n\n\n\n顺便报了清华的开源操作系统训练营，先把 rustlings 刷了。\n\n\n## **总结**\n\n\n这个暑假还是没能静下心来学 cs，原本还计划暑假做完 xv6 的。不过至少最终还是找到了实习，见识了一线互联网大厂员工的工作生活状态，过得也算不错吧。\n\n\n\n实习之后的感受就是完全抽不出时间来学习 cs，一想到毕业以后面临的就是这样的生活就感到非常害怕，想尽量在所剩不多的大学生活中多学习一些 cs 知识。我不确定这样做对我是好是坏，也许我更应该把时间花在研究 android 技术上，这样或许对我的未来的职业生涯更有好处。\n\n\n\n但是学习并不只是为了就业，为了钱。我更希望学习一些更底层的，自己更感兴趣的知识，哪怕在工作上也许很少用到它们。我不想固守在 android 的一亩三分地里，更愿意在计算机科学的海洋中遨游，探索。\n\n\n\n我这样想是对的吗？对我的未来有好处吗？我不知道，但至少可以确定的是我仍然在不断前进，如此就好，这样就好。\n","source":"_posts/2023七月到九月总结.md","raw":"---\ntitle: 2023七月到九月总结\nurlname: LTj7d5ZKsoQ3hRxaA9Acn3WAnUg\ndate: 2023-10-07T22:19:19.000Z\nupdated: '2024-01-18 17:11:20'\ntags: 总结\n---\n# **2023.7～9月总结**\n\n\n从北京回来了，实习基本算告一段落了。至少线下实习告一段落了，能不能继续线上还得等结论。借此机会把 2023.7 ～ 9 月做的事情总结一下：\n\n\n## **7月**\n\n\n原本计划暑假里好好的把 xv6 给刷了，但是学长突然给了我快手实习的内推，于是暂时搁置了 cs 的学习，全心全意准备面试。一面自我感觉还算可以，但快手那边似乎是因为 hc 的问题迟迟不肯安排二面，鸽了我很长一段时间。这段时间最开始我是在准备面试的，然而等了好几天还没收到二面消息就重启了 xv6 的学习，记得是一口气做到了 traps lab，然后收到了快手的拒信。\n\n\n\n收到拒信之后本着一不做二不休的原则又在 boss 直聘上海投，然而只收到了两家公司的面试邀约：禾多科技，字节跳动（抖音开放平台）。\n\n\n\n禾多科技一面只问了20分钟，都是非常基础非常简单的问题，二面直接不问了，直接跟我介绍公司业务（做自动驾驶），但是因为只是随便投来练手的小厂，给的实习工资也不够我在北京生活，就拒了。\n\n\n\n抖音开放平台面试问得比较有水平，可惜我算法苦手，而面试官又比较看重算法这一块，好死不死一面二面的算法题一道都没有做出来，当然是挂了。问了他们的业务，似乎是做抖音小程序的开放 api。\n\n\n## **8月**\n\n\n因为没有找到实习，跟着父母一起去贵州旅游放松一下。这次去贵州旅游的体验确实很不错，印象最深刻的是韭菜坪上的一大片紫色野生韭菜花，非常的漂亮。\n\n\n\n实习的事情在旅行的中途迎来了转机。快手的hr又找上我，告诉我被挂掉的原因是当时没有 hc 了，现在又有 hc 了，如果我还愿意来的话可以直接给我安排二面。而二面的面试官（也就是我后来的 leader）因为急着用人，面试也放了不少水。于是虽然晚了些，我在 8 月 17 号正式入职了快手。\n\n\n\n不得不说那段时间我们部门确实是缺人，我在入职后只熟悉了两天代码便开始做第一个需求，mentor 忙得根本顾不上我，我遇上了问题大多数时候都是问学长（如果没有学长在的话我根本不知道怎么度过实习最开始那段时光）。实习两周之后，我基本熟悉互联网大厂产品的开发流程，并且感觉自己解决眼前的问题的能力有了长足的进步。\n\n\n\n这段时间的实习生活过得很充实，很快乐。不用烦恼学校的事情，还有两位学长陪着。然而基本抽不出时间学 xv6，只在周末的时候完成了两个 lab。\n\n\n## **9月**\n\n\n9月份学长们实习答辩完返校了，有一段时间都是我自己一个人在快手实习。没有了学长们的陪伴，实习生活确实变得乏味了些。然后就是处理一系列学校的破事，原本就打算瞒着辅导员请代课，结果父母不放心给辅导员打了电话。原本辅导员也不想管这个事情，奈何这学期换了个辅导员，这个辅导员是七月份新入职的，俗话说新官上任三把火，她这火直接烧我头上了。\n\n\n\n本来那段时间工作就忙，再加上每天晚上要处理学校的破事，过得非常的痛苦。本来是想至少拖到十月末再回家，但是正巧跟学长们同租的房子也到期了，根本找不到能短租一个月的房子，再加上父母和学校那边给的压力，最后还是决定国庆节就回来。\n\n\n\n顺便报了清华的开源操作系统训练营，先把 rustlings 刷了。\n\n\n## **总结**\n\n\n这个暑假还是没能静下心来学 cs，原本还计划暑假做完 xv6 的。不过至少最终还是找到了实习，见识了一线互联网大厂员工的工作生活状态，过得也算不错吧。\n\n\n\n实习之后的感受就是完全抽不出时间来学习 cs，一想到毕业以后面临的就是这样的生活就感到非常害怕，想尽量在所剩不多的大学生活中多学习一些 cs 知识。我不确定这样做对我是好是坏，也许我更应该把时间花在研究 android 技术上，这样或许对我的未来的职业生涯更有好处。\n\n\n\n但是学习并不只是为了就业，为了钱。我更希望学习一些更底层的，自己更感兴趣的知识，哪怕在工作上也许很少用到它们。我不想固守在 android 的一亩三分地里，更愿意在计算机科学的海洋中遨游，探索。\n\n\n\n我这样想是对的吗？对我的未来有好处吗？我不知道，但至少可以确定的是我仍然在不断前进，如此就好，这样就好。\n","slug":"2023七月到九月总结","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ull70000fbsb46r10n7p","content":"<h1 id=\"2023-7～9月总结\"><a href=\"#2023-7～9月总结\" class=\"headerlink\" title=\"2023.7～9月总结\"></a><strong>2023.7～9月总结</strong></h1><p>从北京回来了，实习基本算告一段落了。至少线下实习告一段落了，能不能继续线上还得等结论。借此机会把 2023.7 ～ 9 月做的事情总结一下：</p>\n<h2 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a><strong>7月</strong></h2><p>原本计划暑假里好好的把 xv6 给刷了，但是学长突然给了我快手实习的内推，于是暂时搁置了 cs 的学习，全心全意准备面试。一面自我感觉还算可以，但快手那边似乎是因为 hc 的问题迟迟不肯安排二面，鸽了我很长一段时间。这段时间最开始我是在准备面试的，然而等了好几天还没收到二面消息就重启了 xv6 的学习，记得是一口气做到了 traps lab，然后收到了快手的拒信。</p>\n<p>收到拒信之后本着一不做二不休的原则又在 boss 直聘上海投，然而只收到了两家公司的面试邀约：禾多科技，字节跳动（抖音开放平台）。</p>\n<p>禾多科技一面只问了20分钟，都是非常基础非常简单的问题，二面直接不问了，直接跟我介绍公司业务（做自动驾驶），但是因为只是随便投来练手的小厂，给的实习工资也不够我在北京生活，就拒了。</p>\n<p>抖音开放平台面试问得比较有水平，可惜我算法苦手，而面试官又比较看重算法这一块，好死不死一面二面的算法题一道都没有做出来，当然是挂了。问了他们的业务，似乎是做抖音小程序的开放 api。</p>\n<h2 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a><strong>8月</strong></h2><p>因为没有找到实习，跟着父母一起去贵州旅游放松一下。这次去贵州旅游的体验确实很不错，印象最深刻的是韭菜坪上的一大片紫色野生韭菜花，非常的漂亮。</p>\n<p>实习的事情在旅行的中途迎来了转机。快手的hr又找上我，告诉我被挂掉的原因是当时没有 hc 了，现在又有 hc 了，如果我还愿意来的话可以直接给我安排二面。而二面的面试官（也就是我后来的 leader）因为急着用人，面试也放了不少水。于是虽然晚了些，我在 8 月 17 号正式入职了快手。</p>\n<p>不得不说那段时间我们部门确实是缺人，我在入职后只熟悉了两天代码便开始做第一个需求，mentor 忙得根本顾不上我，我遇上了问题大多数时候都是问学长（如果没有学长在的话我根本不知道怎么度过实习最开始那段时光）。实习两周之后，我基本熟悉互联网大厂产品的开发流程，并且感觉自己解决眼前的问题的能力有了长足的进步。</p>\n<p>这段时间的实习生活过得很充实，很快乐。不用烦恼学校的事情，还有两位学长陪着。然而基本抽不出时间学 xv6，只在周末的时候完成了两个 lab。</p>\n<h2 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a><strong>9月</strong></h2><p>9月份学长们实习答辩完返校了，有一段时间都是我自己一个人在快手实习。没有了学长们的陪伴，实习生活确实变得乏味了些。然后就是处理一系列学校的破事，原本就打算瞒着辅导员请代课，结果父母不放心给辅导员打了电话。原本辅导员也不想管这个事情，奈何这学期换了个辅导员，这个辅导员是七月份新入职的，俗话说新官上任三把火，她这火直接烧我头上了。</p>\n<p>本来那段时间工作就忙，再加上每天晚上要处理学校的破事，过得非常的痛苦。本来是想至少拖到十月末再回家，但是正巧跟学长们同租的房子也到期了，根本找不到能短租一个月的房子，再加上父母和学校那边给的压力，最后还是决定国庆节就回来。</p>\n<p>顺便报了清华的开源操作系统训练营，先把 rustlings 刷了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>这个暑假还是没能静下心来学 cs，原本还计划暑假做完 xv6 的。不过至少最终还是找到了实习，见识了一线互联网大厂员工的工作生活状态，过得也算不错吧。</p>\n<p>实习之后的感受就是完全抽不出时间来学习 cs，一想到毕业以后面临的就是这样的生活就感到非常害怕，想尽量在所剩不多的大学生活中多学习一些 cs 知识。我不确定这样做对我是好是坏，也许我更应该把时间花在研究 android 技术上，这样或许对我的未来的职业生涯更有好处。</p>\n<p>但是学习并不只是为了就业，为了钱。我更希望学习一些更底层的，自己更感兴趣的知识，哪怕在工作上也许很少用到它们。我不想固守在 android 的一亩三分地里，更愿意在计算机科学的海洋中遨游，探索。</p>\n<p>我这样想是对的吗？对我的未来有好处吗？我不知道，但至少可以确定的是我仍然在不断前进，如此就好，这样就好。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<h1 id=\"2023-7～9月总结\"><a href=\"#2023-7～9月总结\" class=\"headerlink\" title=\"2023.7～9月总结\"></a><strong>2023.7～9月总结</strong></h1><p>从北京回来了，实习基本算告一段落了。至少线下实习告一段落了，能不能继续线上还得等结论。借此机会把 2023.7 ～ 9 月做的事情总结一下：</p>\n<h2 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a><strong>7月</strong></h2><p>原本计划暑假里好好的把 xv6 给刷了，但是学长突然给了我快手实习的内推，于是暂时搁置了 cs 的学习，全心全意准备面试。一面自我感觉还算可以，但快手那边似乎是因为 hc 的问题迟迟不肯安排二面，鸽了我很长一段时间。这段时间最开始我是在准备面试的，然而等了好几天还没收到二面消息就重启了 xv6 的学习，记得是一口气做到了 traps lab，然后收到了快手的拒信。</p>\n<p>收到拒信之后本着一不做二不休的原则又在 boss 直聘上海投，然而只收到了两家公司的面试邀约：禾多科技，字节跳动（抖音开放平台）。</p>\n<p>禾多科技一面只问了20分钟，都是非常基础非常简单的问题，二面直接不问了，直接跟我介绍公司业务（做自动驾驶），但是因为只是随便投来练手的小厂，给的实习工资也不够我在北京生活，就拒了。</p>\n<p>抖音开放平台面试问得比较有水平，可惜我算法苦手，而面试官又比较看重算法这一块，好死不死一面二面的算法题一道都没有做出来，当然是挂了。问了他们的业务，似乎是做抖音小程序的开放 api。</p>\n<h2 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a><strong>8月</strong></h2><p>因为没有找到实习，跟着父母一起去贵州旅游放松一下。这次去贵州旅游的体验确实很不错，印象最深刻的是韭菜坪上的一大片紫色野生韭菜花，非常的漂亮。</p>\n<p>实习的事情在旅行的中途迎来了转机。快手的hr又找上我，告诉我被挂掉的原因是当时没有 hc 了，现在又有 hc 了，如果我还愿意来的话可以直接给我安排二面。而二面的面试官（也就是我后来的 leader）因为急着用人，面试也放了不少水。于是虽然晚了些，我在 8 月 17 号正式入职了快手。</p>\n<p>不得不说那段时间我们部门确实是缺人，我在入职后只熟悉了两天代码便开始做第一个需求，mentor 忙得根本顾不上我，我遇上了问题大多数时候都是问学长（如果没有学长在的话我根本不知道怎么度过实习最开始那段时光）。实习两周之后，我基本熟悉互联网大厂产品的开发流程，并且感觉自己解决眼前的问题的能力有了长足的进步。</p>\n<p>这段时间的实习生活过得很充实，很快乐。不用烦恼学校的事情，还有两位学长陪着。然而基本抽不出时间学 xv6，只在周末的时候完成了两个 lab。</p>\n<h2 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a><strong>9月</strong></h2><p>9月份学长们实习答辩完返校了，有一段时间都是我自己一个人在快手实习。没有了学长们的陪伴，实习生活确实变得乏味了些。然后就是处理一系列学校的破事，原本就打算瞒着辅导员请代课，结果父母不放心给辅导员打了电话。原本辅导员也不想管这个事情，奈何这学期换了个辅导员，这个辅导员是七月份新入职的，俗话说新官上任三把火，她这火直接烧我头上了。</p>\n<p>本来那段时间工作就忙，再加上每天晚上要处理学校的破事，过得非常的痛苦。本来是想至少拖到十月末再回家，但是正巧跟学长们同租的房子也到期了，根本找不到能短租一个月的房子，再加上父母和学校那边给的压力，最后还是决定国庆节就回来。</p>\n<p>顺便报了清华的开源操作系统训练营，先把 rustlings 刷了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>这个暑假还是没能静下心来学 cs，原本还计划暑假做完 xv6 的。不过至少最终还是找到了实习，见识了一线互联网大厂员工的工作生活状态，过得也算不错吧。</p>\n<p>实习之后的感受就是完全抽不出时间来学习 cs，一想到毕业以后面临的就是这样的生活就感到非常害怕，想尽量在所剩不多的大学生活中多学习一些 cs 知识。我不确定这样做对我是好是坏，也许我更应该把时间花在研究 android 技术上，这样或许对我的未来的职业生涯更有好处。</p>\n<p>但是学习并不只是为了就业，为了钱。我更希望学习一些更底层的，自己更感兴趣的知识，哪怕在工作上也许很少用到它们。我不想固守在 android 的一亩三分地里，更愿意在计算机科学的海洋中遨游，探索。</p>\n<p>我这样想是对的吗？对我的未来有好处吗？我不知道，但至少可以确定的是我仍然在不断前进，如此就好，这样就好。</p>\n"},{"title":"2023年度总结","urlname":"Ehapd5iqkom3e3xScJUcxPB7nfe","date":"2023-12-30T18:22:00.000Z","updated":"2024-01-18T09:11:31.000Z","_content":"## **CS 公开课**\n\n- 北大编译实践\n\t- 算是编译器方面的一个启蒙，不过感觉连入门都算不上\n\t\n- CMU 15-213 CSAPP\n\t- 其实课刷得有点马虎，不过把 lab 过完了\n\t\t- 这课早晚得再过一遍\n\t\n- MIT 6.S081\n\t- 对系统内核理解 0 的突破，也学着读了一些英文论文\n\t\n- 参加了清华组织的 rcore 开源操作系统训练营，混了个结营证书\n\t- 因为是实习期间做的，所以其实有点水，不过实验都做完了，也学了一些工程项目中内核的调试方法，也不算毫无收获\n\t\t- 复习了一下 Rust\n\t\n- CS106X （正在学习）\n\t- 本意是想过一遍 cpp，后来发现其实基础的算法和数据结构讲得更多。\n\t\t- 不过听着感觉也不错，巩固下基础，对以后做力扣题也很有帮助。\n\t\n- 参加了达坦科技的 MIT 体系结构公开课开源学习社区，现在在看 MIT 6.004\n\t- 会学 Bluespec，lab 是做 MIT 6.175 的，内容是用 bluespec 搓颗 RISC-V CPU\n\t\n  - 真搓出来了想在上面跑 rcore（_我的天，还有比在自己写的 CPU 上跑自己写的系统内核更酷的事情吗_）\n\n\n\n猛然发现 2023 是我的 CS 启蒙一年，2022 的我在通过红岩网校的考核后便陷入了迷茫。一边维持着摆烂状态，一边漫无目的的倒腾着自己感兴趣的小东西。这期间第一次系统学了 Rust，然后发现了北大的编译实践 lab。做完以后对编译器相关的知识产生了兴趣，想要系统的学习，于是我第一次了解到国外的公开课 （Stanford CS143）。\n\n\n\n其实年初是想系统的学下编译原理（Stanford CS143）的，不过半途而废了。不过在求学的途中听人劝告去学了 CSAPP，之后便一发不可收拾。\n\n\n\n当然我对今年的学习进度并不满意，实在太慢太摸了。接下来计划要学的公开课已经堆积如山了：\n\n\n- CS106L 现代cpp\n\n- CMU 15-445 数据库系统\n\n- MIT 6.824 分布式系统\n\n- CS162 操作系统内核\n\n- CS144 计算机网络\n\n- CS143 编译原理\n\n\n\n任重而道远啊\n\n\n## **其他**\n\n- 去了快手实习\n\t- 嗯，虽然做的都是一些像搬砖一样的业务开发，技术上学不到什么东西。不过至少了解了互联网大厂项目的开发流程，并且在解决具体问题的能力（定位问题，debug，开发业务功能）上有了长足的进步。\n\t\t- 有了这一段实习经历，之后 Android 开发方向的转正实习应该就不难找了，算是给自己留了条后路\n\t\t- 第一次前往异乡租房住，见识了北京浮夸的房价\n\t\n- 思想上发生了转变\n\t- 经过今年发生的事情和我自己的一些思考：\n\t\t- 更愿意相信自由市场\n\t\t\t- 更加忧虑自己的未来，想要轻松的活着，做自己想做的事情\n\t\n- 因为 MyGo 入坑了邦邦，并且在看完后的数个月内念念不忘\n\t- 你能看看 MyGo 吗，我什么都会做的😭\n\t\n\n\n最后说说我目前的目标吧，尽可能多的学习 CS 知识，找一个做基础软件研发的实习，以此为契机确定未来的职业发展方向。当然要是做不到也能滚回去做 Android 开发，至少还有条后路。\n\n\n\n那么，就这样吧，希望 2024 结束时能给自己一个满意的答复。\n","source":"_posts/2023年度总结.md","raw":"---\ntitle: 2023年度总结\nurlname: Ehapd5iqkom3e3xScJUcxPB7nfe\ndate: 2023-12-31T02:22:00.000Z\nupdated: '2024-01-18 17:11:31'\ntags:\n  - 年度总结\n  - 随笔\n---\n## **CS 公开课**\n\n- 北大编译实践\n\t- 算是编译器方面的一个启蒙，不过感觉连入门都算不上\n\t\n- CMU 15-213 CSAPP\n\t- 其实课刷得有点马虎，不过把 lab 过完了\n\t\t- 这课早晚得再过一遍\n\t\n- MIT 6.S081\n\t- 对系统内核理解 0 的突破，也学着读了一些英文论文\n\t\n- 参加了清华组织的 rcore 开源操作系统训练营，混了个结营证书\n\t- 因为是实习期间做的，所以其实有点水，不过实验都做完了，也学了一些工程项目中内核的调试方法，也不算毫无收获\n\t\t- 复习了一下 Rust\n\t\n- CS106X （正在学习）\n\t- 本意是想过一遍 cpp，后来发现其实基础的算法和数据结构讲得更多。\n\t\t- 不过听着感觉也不错，巩固下基础，对以后做力扣题也很有帮助。\n\t\n- 参加了达坦科技的 MIT 体系结构公开课开源学习社区，现在在看 MIT 6.004\n\t- 会学 Bluespec，lab 是做 MIT 6.175 的，内容是用 bluespec 搓颗 RISC-V CPU\n\t\n  - 真搓出来了想在上面跑 rcore（_我的天，还有比在自己写的 CPU 上跑自己写的系统内核更酷的事情吗_）\n\n\n\n猛然发现 2023 是我的 CS 启蒙一年，2022 的我在通过红岩网校的考核后便陷入了迷茫。一边维持着摆烂状态，一边漫无目的的倒腾着自己感兴趣的小东西。这期间第一次系统学了 Rust，然后发现了北大的编译实践 lab。做完以后对编译器相关的知识产生了兴趣，想要系统的学习，于是我第一次了解到国外的公开课 （Stanford CS143）。\n\n\n\n其实年初是想系统的学下编译原理（Stanford CS143）的，不过半途而废了。不过在求学的途中听人劝告去学了 CSAPP，之后便一发不可收拾。\n\n\n\n当然我对今年的学习进度并不满意，实在太慢太摸了。接下来计划要学的公开课已经堆积如山了：\n\n\n- CS106L 现代cpp\n\n- CMU 15-445 数据库系统\n\n- MIT 6.824 分布式系统\n\n- CS162 操作系统内核\n\n- CS144 计算机网络\n\n- CS143 编译原理\n\n\n\n任重而道远啊\n\n\n## **其他**\n\n- 去了快手实习\n\t- 嗯，虽然做的都是一些像搬砖一样的业务开发，技术上学不到什么东西。不过至少了解了互联网大厂项目的开发流程，并且在解决具体问题的能力（定位问题，debug，开发业务功能）上有了长足的进步。\n\t\t- 有了这一段实习经历，之后 Android 开发方向的转正实习应该就不难找了，算是给自己留了条后路\n\t\t- 第一次前往异乡租房住，见识了北京浮夸的房价\n\t\n- 思想上发生了转变\n\t- 经过今年发生的事情和我自己的一些思考：\n\t\t- 更愿意相信自由市场\n\t\t\t- 更加忧虑自己的未来，想要轻松的活着，做自己想做的事情\n\t\n- 因为 MyGo 入坑了邦邦，并且在看完后的数个月内念念不忘\n\t- 你能看看 MyGo 吗，我什么都会做的😭\n\t\n\n\n最后说说我目前的目标吧，尽可能多的学习 CS 知识，找一个做基础软件研发的实习，以此为契机确定未来的职业发展方向。当然要是做不到也能滚回去做 Android 开发，至少还有条后路。\n\n\n\n那么，就这样吧，希望 2024 结束时能给自己一个满意的答复。\n","slug":"2023年度总结","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ulla0001fbsbhpfb0n7c","content":"<h2 id=\"CS-公开课\"><a href=\"#CS-公开课\" class=\"headerlink\" title=\"CS 公开课\"></a><strong>CS 公开课</strong></h2><ul>\n<li><p>北大编译实践</p>\n<ul>\n<li>算是编译器方面的一个启蒙，不过感觉连入门都算不上</li>\n</ul>\n</li>\n<li><p>CMU 15-213 CSAPP</p>\n<ul>\n<li>其实课刷得有点马虎，不过把 lab 过完了<ul>\n<li>这课早晚得再过一遍</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MIT 6.S081</p>\n<ul>\n<li>对系统内核理解 0 的突破，也学着读了一些英文论文</li>\n</ul>\n</li>\n<li><p>参加了清华组织的 rcore 开源操作系统训练营，混了个结营证书</p>\n<ul>\n<li>因为是实习期间做的，所以其实有点水，不过实验都做完了，也学了一些工程项目中内核的调试方法，也不算毫无收获<ul>\n<li>复习了一下 Rust</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CS106X （正在学习）</p>\n<ul>\n<li>本意是想过一遍 cpp，后来发现其实基础的算法和数据结构讲得更多。<ul>\n<li>不过听着感觉也不错，巩固下基础，对以后做力扣题也很有帮助。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参加了达坦科技的 MIT 体系结构公开课开源学习社区，现在在看 MIT 6.004</p>\n<ul>\n<li><p>会学 Bluespec，lab 是做 MIT 6.175 的，内容是用 bluespec 搓颗 RISC-V CPU</p>\n</li>\n<li><p>真搓出来了想在上面跑 rcore（_我的天，还有比在自己写的 CPU 上跑自己写的系统内核更酷的事情吗_）</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>猛然发现 2023 是我的 CS 启蒙一年，2022 的我在通过红岩网校的考核后便陷入了迷茫。一边维持着摆烂状态，一边漫无目的的倒腾着自己感兴趣的小东西。这期间第一次系统学了 Rust，然后发现了北大的编译实践 lab。做完以后对编译器相关的知识产生了兴趣，想要系统的学习，于是我第一次了解到国外的公开课 （Stanford CS143）。</p>\n<p>其实年初是想系统的学下编译原理（Stanford CS143）的，不过半途而废了。不过在求学的途中听人劝告去学了 CSAPP，之后便一发不可收拾。</p>\n<p>当然我对今年的学习进度并不满意，实在太慢太摸了。接下来计划要学的公开课已经堆积如山了：</p>\n<ul>\n<li><p>CS106L 现代cpp</p>\n</li>\n<li><p>CMU 15-445 数据库系统</p>\n</li>\n<li><p>MIT 6.824 分布式系统</p>\n</li>\n<li><p>CS162 操作系统内核</p>\n</li>\n<li><p>CS144 计算机网络</p>\n</li>\n<li><p>CS143 编译原理</p>\n</li>\n</ul>\n<p>任重而道远啊</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h2><ul>\n<li><p>去了快手实习</p>\n<ul>\n<li>嗯，虽然做的都是一些像搬砖一样的业务开发，技术上学不到什么东西。不过至少了解了互联网大厂项目的开发流程，并且在解决具体问题的能力（定位问题，debug，开发业务功能）上有了长足的进步。<ul>\n<li>有了这一段实习经历，之后 Android 开发方向的转正实习应该就不难找了，算是给自己留了条后路</li>\n<li>第一次前往异乡租房住，见识了北京浮夸的房价</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>思想上发生了转变</p>\n<ul>\n<li>经过今年发生的事情和我自己的一些思考：<ul>\n<li>更愿意相信自由市场<ul>\n<li>更加忧虑自己的未来，想要轻松的活着，做自己想做的事情</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>因为 MyGo 入坑了邦邦，并且在看完后的数个月内念念不忘</p>\n<ul>\n<li>你能看看 MyGo 吗，我什么都会做的😭</li>\n</ul>\n</li>\n</ul>\n<p>最后说说我目前的目标吧，尽可能多的学习 CS 知识，找一个做基础软件研发的实习，以此为契机确定未来的职业发展方向。当然要是做不到也能滚回去做 Android 开发，至少还有条后路。</p>\n<p>那么，就这样吧，希望 2024 结束时能给自己一个满意的答复。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<h2 id=\"CS-公开课\"><a href=\"#CS-公开课\" class=\"headerlink\" title=\"CS 公开课\"></a><strong>CS 公开课</strong></h2><ul>\n<li><p>北大编译实践</p>\n<ul>\n<li>算是编译器方面的一个启蒙，不过感觉连入门都算不上</li>\n</ul>\n</li>\n<li><p>CMU 15-213 CSAPP</p>\n<ul>\n<li>其实课刷得有点马虎，不过把 lab 过完了<ul>\n<li>这课早晚得再过一遍</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MIT 6.S081</p>\n<ul>\n<li>对系统内核理解 0 的突破，也学着读了一些英文论文</li>\n</ul>\n</li>\n<li><p>参加了清华组织的 rcore 开源操作系统训练营，混了个结营证书</p>\n<ul>\n<li>因为是实习期间做的，所以其实有点水，不过实验都做完了，也学了一些工程项目中内核的调试方法，也不算毫无收获<ul>\n<li>复习了一下 Rust</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CS106X （正在学习）</p>\n<ul>\n<li>本意是想过一遍 cpp，后来发现其实基础的算法和数据结构讲得更多。<ul>\n<li>不过听着感觉也不错，巩固下基础，对以后做力扣题也很有帮助。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参加了达坦科技的 MIT 体系结构公开课开源学习社区，现在在看 MIT 6.004</p>\n<ul>\n<li><p>会学 Bluespec，lab 是做 MIT 6.175 的，内容是用 bluespec 搓颗 RISC-V CPU</p>\n</li>\n<li><p>真搓出来了想在上面跑 rcore（_我的天，还有比在自己写的 CPU 上跑自己写的系统内核更酷的事情吗_）</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>猛然发现 2023 是我的 CS 启蒙一年，2022 的我在通过红岩网校的考核后便陷入了迷茫。一边维持着摆烂状态，一边漫无目的的倒腾着自己感兴趣的小东西。这期间第一次系统学了 Rust，然后发现了北大的编译实践 lab。做完以后对编译器相关的知识产生了兴趣，想要系统的学习，于是我第一次了解到国外的公开课 （Stanford CS143）。</p>\n<p>其实年初是想系统的学下编译原理（Stanford CS143）的，不过半途而废了。不过在求学的途中听人劝告去学了 CSAPP，之后便一发不可收拾。</p>\n<p>当然我对今年的学习进度并不满意，实在太慢太摸了。接下来计划要学的公开课已经堆积如山了：</p>\n<ul>\n<li><p>CS106L 现代cpp</p>\n</li>\n<li><p>CMU 15-445 数据库系统</p>\n</li>\n<li><p>MIT 6.824 分布式系统</p>\n</li>\n<li><p>CS162 操作系统内核</p>\n</li>\n<li><p>CS144 计算机网络</p>\n</li>\n<li><p>CS143 编译原理</p>\n</li>\n</ul>\n<p>任重而道远啊</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h2><ul>\n<li><p>去了快手实习</p>\n<ul>\n<li>嗯，虽然做的都是一些像搬砖一样的业务开发，技术上学不到什么东西。不过至少了解了互联网大厂项目的开发流程，并且在解决具体问题的能力（定位问题，debug，开发业务功能）上有了长足的进步。<ul>\n<li>有了这一段实习经历，之后 Android 开发方向的转正实习应该就不难找了，算是给自己留了条后路</li>\n<li>第一次前往异乡租房住，见识了北京浮夸的房价</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>思想上发生了转变</p>\n<ul>\n<li>经过今年发生的事情和我自己的一些思考：<ul>\n<li>更愿意相信自由市场<ul>\n<li>更加忧虑自己的未来，想要轻松的活着，做自己想做的事情</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>因为 MyGo 入坑了邦邦，并且在看完后的数个月内念念不忘</p>\n<ul>\n<li>你能看看 MyGo 吗，我什么都会做的😭</li>\n</ul>\n</li>\n</ul>\n<p>最后说说我目前的目标吧，尽可能多的学习 CS 知识，找一个做基础软件研发的实习，以此为契机确定未来的职业发展方向。当然要是做不到也能滚回去做 Android 开发，至少还有条后路。</p>\n<p>那么，就这样吧，希望 2024 结束时能给自己一个满意的答复。</p>\n"},{"title":"Handler Android 消息机制","urlname":"N8Ald4KgDobdVPxjhhHc76zRnVg","date":"2023-07-04T12:49:55.000Z","updated":"2024-01-18T09:31:46.000Z","_content":"## **解析**\n\n\nhandler 源码也算是老生常谈了，之前也简单研究过源码。首先列出比较重要的几个类\n\n\n- Handler\n\n- MessageQueue\n\n- Message\n\n- Looper\n\n\n\n那么我们就从 Handler 最经典的用法开始分析\n\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val handler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            Toast.makeText(this@MainActivity, \"处理消息\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n            setContentView(R.layout.activity_main)\n            handler.sendEmptyMessage(0)\n    }\n}\n```\n\n\n这里就有两个入口可以分析 `Handler#sendMessage`, `Handler#handleMessage`\n\n\n### **Handler#sendMessage**\n\n```java\n// 具体实现看sendMessageDelay\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\n// 具体实现看 sendMessageAtTime\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\n// 拿到字段里的 MessageQueue，然后 enqueueMessage\n// 这个名字很容易猜到这是消息入队的操作\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n        long uptimeMillis) {\n    // 将 msg 的 target 设置为 handler 自身，方便出队后拿到消息的发送者回调 handleMessage\n    msg.target = this;\n    // 设置 workSourceUid\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    // 在new Handler的时候可以设置为异步，这样这个handler发送的消息都是异步消息\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n\n然后我们就进入了 `MessageQueue#enqueueMessage`\n\n\n### **MessageQueue#enqueueMessage**\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n\n    // 上锁，保证没有两条消息同时进行入队操作产生并发问题\n    synchronized (this) {\n        // 如果这个 messgae 正在队列中，当然不能再次入队\n        // 说一点小小的感悟吧，rust语言的移动语义可以让多次入队成为不可能，而在java中为了防范这种边界情况要写大量的检查代码。移动语义这个设计确实高明\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        // 如果这个线程正在退出，当然不能给一条死掉的线程上的handler发消息\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        // 标记这个消息正在使用\n        msg.markInUse();\n        // 设置这条信息应当从队列取出时的时间\n        msg.when = when;\n        // 拿到消息队列的头节点，没错，消息队列是一个链表结构\n        Message p = mMessages;\n        boolean needWake;\n        // 如果头节点为空 或者 when == 0 （意味着这个消息必须放置在头节点）或者 新插入的消息出队时间比头节点早\n        // 就将插入的消息设置为新的头节点\n        // 这里可以看出消息队列是一个优先队列\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            msg.next = p;\n            mMessages = msg;\n            // 如果事件队列现在正处于等待状态就之后唤醒他 （其实就是唤醒epoll等待的事件线程）\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 在队列的中间插入。通常我们不会唤醒这个事件队列除非队列的头部有一个同步屏障\n            // 且这条消息是队列中最早的异步消息\n\n            // 正在阻塞 且 p.target == null 且 是异步消息\n            // 如果 p.target == null 则说明队列的头部是一条屏障消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            // 经典算法题，双指针遍历链表\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                // 遍历到尾部或遍历到了自己应该待的地方 break 出去\n                if (p == null || when < p.when) {\n                    break;\n                }\n                // 如果触发这一行，说明这条消息不是最早的异步消息，那么就不需要唤醒了\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            // 插入\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        // 如果需要唤醒就调用 nativeWake 进到 native 层对事件循环进行唤醒\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n\n激动人心的 native 之旅就要启程啦～\n\n\n```java\nprivate native static void nativeWake(long ptr);\n```\n\n### **native NativeMessageQueue#wake**\n\n\n前往 [AOSPXRef](http://aospxref.com) 查看源码\n\n\n```cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->wake();\n}\n\nvoid NativeMessageQueue::wake() {\n    mLooper->wake();\n}\n```\n\n\n这里可以看出 java 层传入的 mPtr 其实就是 native 层的 MessageQueue 的指针。并且 wake 方法实际上是调用了 `Looper#wake`\n\n\n```cpp\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n    uint64_t inc = 1;\n    // TEMP_FAILURE_RETRY 这个宏用于在系统调用失败时重试\n    // 对 wakeEventFd 这个文件描述符写入唤醒信号 (1)，epoll IO 多路复用机制便会唤醒线程\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n    // 写入失败对应的异常处理\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d (returned %zd): %s\", mWakeEventFd.get(), nWrite, strerror(errno));\n        }\n    }\n}\n```\n\n\n可以看到我们向 mWakeEventFd 写入了唤醒信号，Looper 所对应线程上的 epoll 机制会停止等待唤醒信号，对线程进行唤醒。\n\n\n\n我们知道 epoll 是需要事先注册文件描述符的，找出这部分代码，我们继续分析\n\n\n```cpp\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        mEpollFd.reset();\n    }\n\n    // Allocate the new epoll instance and register the WakeEventFd.\n    // 分配新的 epoll instance 并且注册 WakeEventFd\n    mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC));\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance: %s\", strerror(errno));\n\n    // 创建 epoll 事件 wakeEvent\n    epoll_event wakeEvent = createEpollEvent(EPOLLIN, WAKE_EVENT_FD_SEQ);\n    // 注册文件描述符\n    int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &wakeEvent);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\",\n            strerror(errno));\n\n    // 注册其他 epoll 事件：比如屏幕触摸事件，触摸屏幕时需要唤醒线程并在主线程回调 onTouch\n    for (const auto& [seq, request] : mRequests) {\n        epoll_event eventItem = createEpollEvent(request.getEpollEvents(), seq);\n\n        int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set: %s\",\n                    request.fd, strerror(errno));\n        }\n    }\n}\n```\n\n\n注册了之后，问题是在哪里进行 `epoll_wait` 等待呢？在这里先按下不表，我们从 `Handler#handleMessage` 开始分析。\n\n\n### **Handler#handleMessage**\n\n```java\n// Handler#dispatchMessage\npublic void dispatchMessage(@NonNull Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n\n### **Looper#loopOnce**\n\n```java\n// Looper#loopOnce\nprivate static boolean loopOnce(final Looper me,\n        final long ident, final int thresholdOverride) {\n\n    // 重要步骤，从队列中取出消息\n    Message msg = me.mQueue.next(); // might block\n    if (msg == null) {\n        // No message indicates that the message queue is quitting.\n        return false;\n    }\n\n    // This must be in a local variable, in case a UI event sets the logger\n    final Printer logging = me.mLogging;\n    if (logging != null) {\n        logging.println(\">>>>> Dispatching to \" + msg.target + \" \"\n                + msg.callback + \": \" + msg.what);\n    }\n    // Make sure the observer won't change while processing a transaction.\n    // 这个 Observer 可以在消息处理前和消息处理后做一些事情\n    final Observer observer = sObserver;\n\n    final long traceTag = me.mTraceTag;\n    long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;\n    long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;\n    if (thresholdOverride > 0) {\n        slowDispatchThresholdMs = thresholdOverride;\n        slowDeliveryThresholdMs = thresholdOverride;\n    }\n    final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);\n    final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);\n\n    final boolean needStartTime = logSlowDelivery || logSlowDispatch;\n    final boolean needEndTime = logSlowDispatch;\n\n    if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n    }\n\n    final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;\n    final long dispatchEnd;\n    Object token = null;\n    if (observer != null) {\n        token = observer.messageDispatchStarting();\n    }\n    long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);\n    try {\n        // 在这里把消息发给 Handler\n        msg.target.dispatchMessage(msg);\n        if (observer != null) {\n            observer.messageDispatched(token, msg);\n        }\n        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;\n    } catch (Exception exception) {\n        if (observer != null) {\n            observer.dispatchingThrewException(token, msg, exception);\n        }\n        throw exception;\n    } finally {\n        ThreadLocalWorkSource.restore(origWorkSource);\n        if (traceTag != 0) {\n            Trace.traceEnd(traceTag);\n        }\n    }\n    if (logSlowDelivery) {\n        if (me.mSlowDeliveryDetected) {\n            if ((dispatchStart - msg.when) <= 10) {\n                Slog.w(TAG, \"Drained\");\n                me.mSlowDeliveryDetected = false;\n            }\n        } else {\n            if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\",\n                        msg)) {\n                // Once we write a slow delivery log, suppress until the queue drains.\n                me.mSlowDeliveryDetected = true;\n            }\n        }\n    }\n    if (logSlowDispatch) {\n        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg);\n    }\n\n    if (logging != null) {\n        logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n    }\n\n    // Make sure that during the course of dispatching the\n    // identity of the thread wasn't corrupted.\n    final long newIdent = Binder.clearCallingIdentity();\n    if (ident != newIdent) {\n        Log.wtf(TAG, \"Thread identity changed from 0x\"\n                + Long.toHexString(ident) + \" to 0x\"\n                + Long.toHexString(newIdent) + \" while dispatching to \"\n                + msg.target.getClass().getName() + \" \"\n                + msg.callback + \" what=\" + msg.what);\n    }\n\n    // 消息已经用完了，清除状态放入实例池\n    msg.recycleUnchecked();\n\n    return true;\n}\n```\n\n\n别看上面一大堆代码，其实核心逻辑就是 `MessageQueue#next` 取出消息并把它分发给 `Handler`。其他的代码基本上就是单个消息处理太慢的警告机制。\n\n\n### **Looper#loop**\n\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    if (me.mInLoop) {\n        Slog.w(TAG, \"Loop again would have the queued messages be executed\"\n                + \" before this one completed.\");\n    }\n\n    me.mInLoop = true;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    // Allow overriding a threshold with a system prop. e.g.\n    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'\n    final int thresholdOverride =\n        SystemProperties.getInt(\"log.looper.\"\n                + Process.myUid() + \".\"\n                + Thread.currentThread().getName()\n                + \".slow\", 0);\n\n    me.mSlowDeliveryDetected = false;\n\n    for (;;) {\n        if (!loopOnce(me, ident, thresholdOverride)) {\n            return;\n        }\n    }\n}\n```\n\n\n重要代码也就是最后的死循环，这个死循环只会在 MessageQueue 正在退出的时候返回。\n\n\n### **MessageQueue#next**\n\n\n重头戏来了\n\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    // 这里出现了 IdleHandler 的字眼\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // pollOnce 其实就是一个设置了超时时间的 epoll_wait\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n\n            // 消息队列的头部有同步屏障\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 找出队列中的首个异步消息\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            // 如果有消息\n            if (msg != null) {\n                // 这个消息还没有到时间，设置一下下轮循环执行的 pollOnce 的超时时间\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 这个消息已经到时间了，从消息队列中取出返回\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // 队列空了，进入无限期的 epoll_wait 等待\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // 这里是 IdleHandler 相关的内容，先去看看 IdleHandler 这个东西怎么用\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 第一次空闲的时候，记录要运行的 idlehandler 的数量。\n            // 空闲处理只在队列为空或第一条消息需要等待一段时间的时候执行\n            // 说白了就是在 pollOnce 之前执行\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // 没有 IdleHandler 的情况下单次循环在这里结束\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            // 最大只会执行4个 IdleHandler\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            // 执行\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n            // 不保留就删掉\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // 重制数量\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // 执行了idleHandler就不等待了，因为可能在idleHandler中已经发送了新的消息，重走一遍流程\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n### **native Looper#pollOnce**\n\n```cpp\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != nullptr) *outFd = fd;\n                if (outEvents != nullptr) *outEvents = events;\n                if (outData != nullptr) *outData = data;\n                return ident;\n            }\n        }\n\n        // result != 0 时可以退出\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != nullptr) *outFd = 0;\n            if (outEvents != nullptr) *outEvents = 0;\n            if (outData != nullptr) *outData = nullptr;\n            return result;\n        }\n\n        // 这里如果返回0的话就要一直跑这个方法，不过我们知道pollInner实际上是不会返回的 (epoll_wait)\n        // 所以在这里猜测正常情况下返回就退出循环，只有在某些情况下需要重试?\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n\n接下来看看 pollInner，东西真多，我们只关注重点代码\n\n\n```cpp\nint Looper::pollInner(int timeoutMillis) {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);\n#endif\n\n    // Adjust the timeout based on when the next message is due.\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - next message in %\" PRId64 \"ns, adjusted timeout: timeoutMillis=%d\",\n                this, mNextMessageUptime - now, timeoutMillis);\n#endif\n    }\n\n    // Poll.\n    // result的取值有四种: POLL_WAKE = -1 POLL_CALLBACK = -2 POLL_TIMEOUT = -3 POLL_ERROR = -4\n    int result = POLL_WAKE;\n    mResponses.clear();\n    mResponseIndex = 0;\n\n    // We are about to idle.\n    mPolling = true;\n\n    // 创建事件集合eventItems，EPOLL_MAX_EVENTS=16\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用epoll_wait()来等待事件，如果有事件，就放入事件集合eventItems中，并返回事件数量，如果没有，就一直等，超时时间为我们传入的timeoutMillis\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n\n    // No longer idling.\n    mPolling = false;\n\n    // Acquire lock.\n    // 加锁\n    mLock.lock();\n\n    // Rebuild epoll set if needed.\n    if (mEpollRebuildRequired) {\n        mEpollRebuildRequired = false;\n        rebuildEpollLocked();\n        goto Done;\n    }\n\n    // Check for poll error.\n    // 如果发生的事件小于0，说明 epoll_wait 出异常了，设置 result 为 POLL_ERROR 后跳转到 Done\n    if (eventCount < 0) {\n        if (errno == EINTR) {\n            goto Done;\n        }\n        ALOGW(\"Poll failed with an unexpected error: %s\", strerror(errno));\n        result = POLL_ERROR;\n        goto Done;\n    }\n\n    // Check for poll timeout.\n    // epoll_wait 超时返回，跳转到 Done\n    if (eventCount == 0) {\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - timeout\", this);\n#endif\n        result = POLL_TIMEOUT;\n        goto Done;\n    }\n\n    // Handle all events.\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - handling events from %d fds\", this, eventCount);\n#endif\n\n    // 走到这里说明有事件\n    for (int i = 0; i < eventCount; i++) {\n        // 挨个取出事件进行响应\n        const SequenceNumber seq = eventItems[i].data.u64;\n        uint32_t epollEvents = eventItems[i].events;\n        // 是 wake event\n        if (seq == WAKE_EVENT_FD_SEQ) {\n            if (epollEvents & EPOLLIN) {\n                // 清除 wakeEventFd 的事件循环计数器，以便接收下一次事件\n                // 事件文件描述符（如 eventfd）被设置为边缘触发（ET）模式。\n                // 这意味着只有在状态发生变化时，epoll 才会返回这个文件描述符的事件。\n                // 如果你不读取这个事件，状态就不会改变，所以 epoll 可能不会再次返回这个事件，即使有新的唤醒事件发生。\n                awoken();\n            } else {\n                ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents);\n            }\n        } else {\n            // 响应其他事件\n            const auto& request_it = mRequests.find(seq);\n            if (request_it != mRequests.end()) {\n                const auto& request = request_it->second;\n                int events = 0;\n                if (epollEvents & EPOLLIN) events |= EVENT_INPUT;\n                if (epollEvents & EPOLLOUT) events |= EVENT_OUTPUT;\n                if (epollEvents & EPOLLERR) events |= EVENT_ERROR;\n                if (epollEvents & EPOLLHUP) events |= EVENT_HANGUP;\n                mResponses.push({.seq = seq, .events = events, .request = request});\n            } else {\n                ALOGW(\"Ignoring unexpected epoll events 0x%x for sequence number %\" PRIu64\n                        \" that is no longer registered.\",\n                        epollEvents, seq);\n            }\n        }\n    }\nDone: ;\n\n      // Invoke pending message callbacks.\n      // 这里就是处理 native 层的消息，跟 java 层 handler 的逻辑差不多\n      // native 层的消息是用 vector 存的\n      mNextMessageUptime = LLONG_MAX;\n      while (mMessageEnvelopes.size() != 0) {\n          nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n          const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);\n          // 消息到期\n          if (messageEnvelope.uptime <= now) {\n              // Remove the envelope from the list.\n              // We keep a strong reference to the handler until the call to handleMessage\n              // finishes.  Then we drop it so that the handler can be deleted *before*\n              // we reacquire our lock.\n              { // obtain handler\n                  sp<MessageHandler> handler = messageEnvelope.handler;\n                  Message message = messageEnvelope.message;\n                  mMessageEnvelopes.removeAt(0);\n                  mSendingMessage = true;\n                  mLock.unlock();\n\n#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS\n                  ALOGD(\"%p ~ pollOnce - sending message: handler=%p, what=%d\",\n                          this, handler.get(), message.what);\n#endif\n                  // 回调 native 层 handler 的 handleMessage\n                  handler->handleMessage(message);\n              } // release handler\n\n              mLock.lock();\n              mSendingMessage = false;\n              // 这里 result 就是把message回调给了handler\n              result = POLL_CALLBACK;\n          } else {\n              // The last message left at the head of the queue determines the next wakeup time.\n              // 设置下条消息到期的时间 并跳出循环等待Java层的下一次轮询\n              mNextMessageUptime = messageEnvelope.uptime;\n              break;\n          }\n      }\n\n      // Release lock.\n      mLock.unlock();\n\n      // Invoke all response callbacks.\n      for (size_t i = 0; i < mResponses.size(); i++) {\n          Response& response = mResponses.editItemAt(i);\n          if (response.request.ident == POLL_CALLBACK) {\n              int fd = response.request.fd;\n              int events = response.events;\n              void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS\n              ALOGD(\"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p\",\n                      this, response.request.callback.get(), fd, events, data);\n#endif\n              // Invoke the callback.  Note that the file descriptor may be closed by\n              // the callback (and potentially even reused) before the function returns so\n              // we need to be a little careful when removing the file descriptor afterwards.\n              int callbackResult = response.request.callback->handleEvent(fd, events, data);\n              if (callbackResult == 0) {\n                  AutoMutex _l(mLock);\n                  removeSequenceNumberLocked(response.seq);\n              }\n\n              // Clear the callback reference in the response structure promptly because we\n              // will not clear the response vector itself until the next poll.\n              response.request.callback.clear();\n              result = POLL_CALLBACK;\n          }\n      }\n      return result;\n}\n```\n\n\n总体流程其实就是 epoll_wait 拿到事件，处理事件并让 native 层的消息队列取一次消息。\n\n\n## **面试题**\n\n\n> 来自蔷神\n\n\n### **handler大致运转过程**\n\n\n`Handler#sendMessage` -> `MessageQueue#enqueueMessage` 消息入队 -> 如果消息入队时处于头部，或头部有同步屏障且插入的消息为最早的异步消息则唤醒 Looper `NativeMessageQueue#wake`\n\n\n\nLooper 被唤醒后轮询取消息，取到消息后看消息是否过期，如果没有过期就 pollOnce 等待至过期，过期了就出队发给 Handler，直到没有更多消息时 pollOnce 的过期时间被设置为 -1，无限期等待直到有新消息插入。\n\n\n### **handler消息类型以及每个类型的区别**\n\n\n同步消息，异步消息，同步屏障\n\n\n### **同步消息屏障的意义是什么? 通常用来干嘛?**\n\n\n其实比较类似一些异步任务调度机制的任务偷取（好像内核态的任务调度也有偷取这个机制？）\n\n\n\n在消息过多处理不过来的情况下优先处理异步消息，异步消息的异步其实指的就是不按消息队列中消息的顺序执行（毕竟在遇到屏障的时候只处理异步事件，不处理同步事件）\n\n\n\n同步屏障用完要记得撤销，不然就再也接收不到同步消息了\n\n\n### **如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?**\n\n\n那肯定不new，使用 `Message.obtain` 从对象池中拿取。如果发送消息都直接new的话会对堆内存造成较大负担，所以才有对象复用机制。\n\n\n### **idlehandler是什么**\n\n\nidlehandler 就是在消息队列取空或下一个消息需要等待时即将进入 pollOnce 等待之前回调的一个接口。\n\n\n```java\npublic static interface IdleHandler {\n    // 返回 false 就会在回调一次后移除\n    // 返回 true 则会一直保留\n    boolean queueIdle(); \n}\n```\n\n### **idlehandler可以用来做哪一类任务**\n\n\n执行优先级足够低的任务\n\n\n### **如果我频繁添加idlehandler是否发生anr**\n\n\n只要 idlehandler 中的处理没有耗时逻辑就不会，每次空闲执行的 idlehandler 不会超过4个。\n\n\n### **looper的loop是死循环会造成anr嘛？为什么**\n\n\n不会，因为 loop 进去有消息的时候会处理消息，没有消息的时候会进入 epoll 等待，anr 的原因在于没有及时处理消息。\n\n\n###  **ANR 的原因**\n - **系统进程(system_server)** 调度，设置定时监控（即埋下炸弹）\n\n - system_server 进程将任务派发到**应用进程**完成对消息的实际处理(执行任务)\n\n - 最后，执行任务时间过长，在定时器超时前 system_server 还**未收到任务完成的通知**，触发 ANR（炸弹爆炸）\n\n\n\n没有及时处理 system_server 派发的任务，system_server 没有收到任务完成的通知，就触发了 ANR。\n\n\n### **handler looper messagequeue是怎么个关系一对一还是一对多，多对多**\n\n\nLooper 跟 MessageQueue 是一对一的关系。MessageQueue 跟 Handler 是一对多的关系。\n\n\n### **looper和thread是一对一的关系是如何实现的**\n\n\n使用 ThreadLocal 保存 Looper 实例\n\n\n### **threadlocal是什么，有用过吗**\n\n\nThreadLocal 本质上是保存在 Thread 上面的一张 HashMap，不同之处在与它的键使用 WeakReference 存储，在 set 时会清理 key == null 的键值对。但用完的时候最好手动 remove，不然还是会内存泄漏。使用弱引用只是让 ThreadLocalMap 持有的 ThreadLocal 不会内存泄漏，ThreadLocal 对应的值还是会内存泄漏。\n\n\n### **messagequeue是什么数据结构**\n\n\n链表实现的优先队列\n\n\n### **延迟消息是如何实现的**\n\n\n消息队列是一个优先队列，插入时进行排序。插入时如果消息处于头部，且事件队列处于等待状态就唤醒它，Looper 拿了头部的消息就会 `pollOnce` 等待这个消息需要等待的时间后再将消息出队传递给 Handler。如果有队列顶部有同步屏障的话，最早的异步消息将会进行唤醒处理。\n\n\n","source":"_posts/Handler Android 消息机制.md","raw":"---\ntitle: Handler Android 消息机制\nurlname: N8Ald4KgDobdVPxjhhHc76zRnVg\ndate: 2023-07-04T20:49:55.000Z\nupdated: '2024-01-18 17:31:46'\ntags:\n  - android\n  - 八股\n---\n## **解析**\n\n\nhandler 源码也算是老生常谈了，之前也简单研究过源码。首先列出比较重要的几个类\n\n\n- Handler\n\n- MessageQueue\n\n- Message\n\n- Looper\n\n\n\n那么我们就从 Handler 最经典的用法开始分析\n\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val handler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            Toast.makeText(this@MainActivity, \"处理消息\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n            setContentView(R.layout.activity_main)\n            handler.sendEmptyMessage(0)\n    }\n}\n```\n\n\n这里就有两个入口可以分析 `Handler#sendMessage`, `Handler#handleMessage`\n\n\n### **Handler#sendMessage**\n\n```java\n// 具体实现看sendMessageDelay\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\n// 具体实现看 sendMessageAtTime\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\n// 拿到字段里的 MessageQueue，然后 enqueueMessage\n// 这个名字很容易猜到这是消息入队的操作\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n        long uptimeMillis) {\n    // 将 msg 的 target 设置为 handler 自身，方便出队后拿到消息的发送者回调 handleMessage\n    msg.target = this;\n    // 设置 workSourceUid\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    // 在new Handler的时候可以设置为异步，这样这个handler发送的消息都是异步消息\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n\n然后我们就进入了 `MessageQueue#enqueueMessage`\n\n\n### **MessageQueue#enqueueMessage**\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n\n    // 上锁，保证没有两条消息同时进行入队操作产生并发问题\n    synchronized (this) {\n        // 如果这个 messgae 正在队列中，当然不能再次入队\n        // 说一点小小的感悟吧，rust语言的移动语义可以让多次入队成为不可能，而在java中为了防范这种边界情况要写大量的检查代码。移动语义这个设计确实高明\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        // 如果这个线程正在退出，当然不能给一条死掉的线程上的handler发消息\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        // 标记这个消息正在使用\n        msg.markInUse();\n        // 设置这条信息应当从队列取出时的时间\n        msg.when = when;\n        // 拿到消息队列的头节点，没错，消息队列是一个链表结构\n        Message p = mMessages;\n        boolean needWake;\n        // 如果头节点为空 或者 when == 0 （意味着这个消息必须放置在头节点）或者 新插入的消息出队时间比头节点早\n        // 就将插入的消息设置为新的头节点\n        // 这里可以看出消息队列是一个优先队列\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            msg.next = p;\n            mMessages = msg;\n            // 如果事件队列现在正处于等待状态就之后唤醒他 （其实就是唤醒epoll等待的事件线程）\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 在队列的中间插入。通常我们不会唤醒这个事件队列除非队列的头部有一个同步屏障\n            // 且这条消息是队列中最早的异步消息\n\n            // 正在阻塞 且 p.target == null 且 是异步消息\n            // 如果 p.target == null 则说明队列的头部是一条屏障消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            // 经典算法题，双指针遍历链表\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                // 遍历到尾部或遍历到了自己应该待的地方 break 出去\n                if (p == null || when < p.when) {\n                    break;\n                }\n                // 如果触发这一行，说明这条消息不是最早的异步消息，那么就不需要唤醒了\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            // 插入\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        // 如果需要唤醒就调用 nativeWake 进到 native 层对事件循环进行唤醒\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n\n激动人心的 native 之旅就要启程啦～\n\n\n```java\nprivate native static void nativeWake(long ptr);\n```\n\n### **native NativeMessageQueue#wake**\n\n\n前往 [AOSPXRef](http://aospxref.com) 查看源码\n\n\n```cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->wake();\n}\n\nvoid NativeMessageQueue::wake() {\n    mLooper->wake();\n}\n```\n\n\n这里可以看出 java 层传入的 mPtr 其实就是 native 层的 MessageQueue 的指针。并且 wake 方法实际上是调用了 `Looper#wake`\n\n\n```cpp\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n    uint64_t inc = 1;\n    // TEMP_FAILURE_RETRY 这个宏用于在系统调用失败时重试\n    // 对 wakeEventFd 这个文件描述符写入唤醒信号 (1)，epoll IO 多路复用机制便会唤醒线程\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n    // 写入失败对应的异常处理\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d (returned %zd): %s\", mWakeEventFd.get(), nWrite, strerror(errno));\n        }\n    }\n}\n```\n\n\n可以看到我们向 mWakeEventFd 写入了唤醒信号，Looper 所对应线程上的 epoll 机制会停止等待唤醒信号，对线程进行唤醒。\n\n\n\n我们知道 epoll 是需要事先注册文件描述符的，找出这部分代码，我们继续分析\n\n\n```cpp\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        mEpollFd.reset();\n    }\n\n    // Allocate the new epoll instance and register the WakeEventFd.\n    // 分配新的 epoll instance 并且注册 WakeEventFd\n    mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC));\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance: %s\", strerror(errno));\n\n    // 创建 epoll 事件 wakeEvent\n    epoll_event wakeEvent = createEpollEvent(EPOLLIN, WAKE_EVENT_FD_SEQ);\n    // 注册文件描述符\n    int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &wakeEvent);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\",\n            strerror(errno));\n\n    // 注册其他 epoll 事件：比如屏幕触摸事件，触摸屏幕时需要唤醒线程并在主线程回调 onTouch\n    for (const auto& [seq, request] : mRequests) {\n        epoll_event eventItem = createEpollEvent(request.getEpollEvents(), seq);\n\n        int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set: %s\",\n                    request.fd, strerror(errno));\n        }\n    }\n}\n```\n\n\n注册了之后，问题是在哪里进行 `epoll_wait` 等待呢？在这里先按下不表，我们从 `Handler#handleMessage` 开始分析。\n\n\n### **Handler#handleMessage**\n\n```java\n// Handler#dispatchMessage\npublic void dispatchMessage(@NonNull Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n\n### **Looper#loopOnce**\n\n```java\n// Looper#loopOnce\nprivate static boolean loopOnce(final Looper me,\n        final long ident, final int thresholdOverride) {\n\n    // 重要步骤，从队列中取出消息\n    Message msg = me.mQueue.next(); // might block\n    if (msg == null) {\n        // No message indicates that the message queue is quitting.\n        return false;\n    }\n\n    // This must be in a local variable, in case a UI event sets the logger\n    final Printer logging = me.mLogging;\n    if (logging != null) {\n        logging.println(\">>>>> Dispatching to \" + msg.target + \" \"\n                + msg.callback + \": \" + msg.what);\n    }\n    // Make sure the observer won't change while processing a transaction.\n    // 这个 Observer 可以在消息处理前和消息处理后做一些事情\n    final Observer observer = sObserver;\n\n    final long traceTag = me.mTraceTag;\n    long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;\n    long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;\n    if (thresholdOverride > 0) {\n        slowDispatchThresholdMs = thresholdOverride;\n        slowDeliveryThresholdMs = thresholdOverride;\n    }\n    final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);\n    final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);\n\n    final boolean needStartTime = logSlowDelivery || logSlowDispatch;\n    final boolean needEndTime = logSlowDispatch;\n\n    if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n    }\n\n    final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;\n    final long dispatchEnd;\n    Object token = null;\n    if (observer != null) {\n        token = observer.messageDispatchStarting();\n    }\n    long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);\n    try {\n        // 在这里把消息发给 Handler\n        msg.target.dispatchMessage(msg);\n        if (observer != null) {\n            observer.messageDispatched(token, msg);\n        }\n        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;\n    } catch (Exception exception) {\n        if (observer != null) {\n            observer.dispatchingThrewException(token, msg, exception);\n        }\n        throw exception;\n    } finally {\n        ThreadLocalWorkSource.restore(origWorkSource);\n        if (traceTag != 0) {\n            Trace.traceEnd(traceTag);\n        }\n    }\n    if (logSlowDelivery) {\n        if (me.mSlowDeliveryDetected) {\n            if ((dispatchStart - msg.when) <= 10) {\n                Slog.w(TAG, \"Drained\");\n                me.mSlowDeliveryDetected = false;\n            }\n        } else {\n            if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\",\n                        msg)) {\n                // Once we write a slow delivery log, suppress until the queue drains.\n                me.mSlowDeliveryDetected = true;\n            }\n        }\n    }\n    if (logSlowDispatch) {\n        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg);\n    }\n\n    if (logging != null) {\n        logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n    }\n\n    // Make sure that during the course of dispatching the\n    // identity of the thread wasn't corrupted.\n    final long newIdent = Binder.clearCallingIdentity();\n    if (ident != newIdent) {\n        Log.wtf(TAG, \"Thread identity changed from 0x\"\n                + Long.toHexString(ident) + \" to 0x\"\n                + Long.toHexString(newIdent) + \" while dispatching to \"\n                + msg.target.getClass().getName() + \" \"\n                + msg.callback + \" what=\" + msg.what);\n    }\n\n    // 消息已经用完了，清除状态放入实例池\n    msg.recycleUnchecked();\n\n    return true;\n}\n```\n\n\n别看上面一大堆代码，其实核心逻辑就是 `MessageQueue#next` 取出消息并把它分发给 `Handler`。其他的代码基本上就是单个消息处理太慢的警告机制。\n\n\n### **Looper#loop**\n\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    if (me.mInLoop) {\n        Slog.w(TAG, \"Loop again would have the queued messages be executed\"\n                + \" before this one completed.\");\n    }\n\n    me.mInLoop = true;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    // Allow overriding a threshold with a system prop. e.g.\n    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'\n    final int thresholdOverride =\n        SystemProperties.getInt(\"log.looper.\"\n                + Process.myUid() + \".\"\n                + Thread.currentThread().getName()\n                + \".slow\", 0);\n\n    me.mSlowDeliveryDetected = false;\n\n    for (;;) {\n        if (!loopOnce(me, ident, thresholdOverride)) {\n            return;\n        }\n    }\n}\n```\n\n\n重要代码也就是最后的死循环，这个死循环只会在 MessageQueue 正在退出的时候返回。\n\n\n### **MessageQueue#next**\n\n\n重头戏来了\n\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    // 这里出现了 IdleHandler 的字眼\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // pollOnce 其实就是一个设置了超时时间的 epoll_wait\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n\n            // 消息队列的头部有同步屏障\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 找出队列中的首个异步消息\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            // 如果有消息\n            if (msg != null) {\n                // 这个消息还没有到时间，设置一下下轮循环执行的 pollOnce 的超时时间\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 这个消息已经到时间了，从消息队列中取出返回\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // 队列空了，进入无限期的 epoll_wait 等待\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // 这里是 IdleHandler 相关的内容，先去看看 IdleHandler 这个东西怎么用\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 第一次空闲的时候，记录要运行的 idlehandler 的数量。\n            // 空闲处理只在队列为空或第一条消息需要等待一段时间的时候执行\n            // 说白了就是在 pollOnce 之前执行\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // 没有 IdleHandler 的情况下单次循环在这里结束\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            // 最大只会执行4个 IdleHandler\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            // 执行\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n            // 不保留就删掉\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // 重制数量\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // 执行了idleHandler就不等待了，因为可能在idleHandler中已经发送了新的消息，重走一遍流程\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n### **native Looper#pollOnce**\n\n```cpp\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != nullptr) *outFd = fd;\n                if (outEvents != nullptr) *outEvents = events;\n                if (outData != nullptr) *outData = data;\n                return ident;\n            }\n        }\n\n        // result != 0 时可以退出\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != nullptr) *outFd = 0;\n            if (outEvents != nullptr) *outEvents = 0;\n            if (outData != nullptr) *outData = nullptr;\n            return result;\n        }\n\n        // 这里如果返回0的话就要一直跑这个方法，不过我们知道pollInner实际上是不会返回的 (epoll_wait)\n        // 所以在这里猜测正常情况下返回就退出循环，只有在某些情况下需要重试?\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n\n接下来看看 pollInner，东西真多，我们只关注重点代码\n\n\n```cpp\nint Looper::pollInner(int timeoutMillis) {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);\n#endif\n\n    // Adjust the timeout based on when the next message is due.\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - next message in %\" PRId64 \"ns, adjusted timeout: timeoutMillis=%d\",\n                this, mNextMessageUptime - now, timeoutMillis);\n#endif\n    }\n\n    // Poll.\n    // result的取值有四种: POLL_WAKE = -1 POLL_CALLBACK = -2 POLL_TIMEOUT = -3 POLL_ERROR = -4\n    int result = POLL_WAKE;\n    mResponses.clear();\n    mResponseIndex = 0;\n\n    // We are about to idle.\n    mPolling = true;\n\n    // 创建事件集合eventItems，EPOLL_MAX_EVENTS=16\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 调用epoll_wait()来等待事件，如果有事件，就放入事件集合eventItems中，并返回事件数量，如果没有，就一直等，超时时间为我们传入的timeoutMillis\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n\n    // No longer idling.\n    mPolling = false;\n\n    // Acquire lock.\n    // 加锁\n    mLock.lock();\n\n    // Rebuild epoll set if needed.\n    if (mEpollRebuildRequired) {\n        mEpollRebuildRequired = false;\n        rebuildEpollLocked();\n        goto Done;\n    }\n\n    // Check for poll error.\n    // 如果发生的事件小于0，说明 epoll_wait 出异常了，设置 result 为 POLL_ERROR 后跳转到 Done\n    if (eventCount < 0) {\n        if (errno == EINTR) {\n            goto Done;\n        }\n        ALOGW(\"Poll failed with an unexpected error: %s\", strerror(errno));\n        result = POLL_ERROR;\n        goto Done;\n    }\n\n    // Check for poll timeout.\n    // epoll_wait 超时返回，跳转到 Done\n    if (eventCount == 0) {\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - timeout\", this);\n#endif\n        result = POLL_TIMEOUT;\n        goto Done;\n    }\n\n    // Handle all events.\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - handling events from %d fds\", this, eventCount);\n#endif\n\n    // 走到这里说明有事件\n    for (int i = 0; i < eventCount; i++) {\n        // 挨个取出事件进行响应\n        const SequenceNumber seq = eventItems[i].data.u64;\n        uint32_t epollEvents = eventItems[i].events;\n        // 是 wake event\n        if (seq == WAKE_EVENT_FD_SEQ) {\n            if (epollEvents & EPOLLIN) {\n                // 清除 wakeEventFd 的事件循环计数器，以便接收下一次事件\n                // 事件文件描述符（如 eventfd）被设置为边缘触发（ET）模式。\n                // 这意味着只有在状态发生变化时，epoll 才会返回这个文件描述符的事件。\n                // 如果你不读取这个事件，状态就不会改变，所以 epoll 可能不会再次返回这个事件，即使有新的唤醒事件发生。\n                awoken();\n            } else {\n                ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents);\n            }\n        } else {\n            // 响应其他事件\n            const auto& request_it = mRequests.find(seq);\n            if (request_it != mRequests.end()) {\n                const auto& request = request_it->second;\n                int events = 0;\n                if (epollEvents & EPOLLIN) events |= EVENT_INPUT;\n                if (epollEvents & EPOLLOUT) events |= EVENT_OUTPUT;\n                if (epollEvents & EPOLLERR) events |= EVENT_ERROR;\n                if (epollEvents & EPOLLHUP) events |= EVENT_HANGUP;\n                mResponses.push({.seq = seq, .events = events, .request = request});\n            } else {\n                ALOGW(\"Ignoring unexpected epoll events 0x%x for sequence number %\" PRIu64\n                        \" that is no longer registered.\",\n                        epollEvents, seq);\n            }\n        }\n    }\nDone: ;\n\n      // Invoke pending message callbacks.\n      // 这里就是处理 native 层的消息，跟 java 层 handler 的逻辑差不多\n      // native 层的消息是用 vector 存的\n      mNextMessageUptime = LLONG_MAX;\n      while (mMessageEnvelopes.size() != 0) {\n          nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n          const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);\n          // 消息到期\n          if (messageEnvelope.uptime <= now) {\n              // Remove the envelope from the list.\n              // We keep a strong reference to the handler until the call to handleMessage\n              // finishes.  Then we drop it so that the handler can be deleted *before*\n              // we reacquire our lock.\n              { // obtain handler\n                  sp<MessageHandler> handler = messageEnvelope.handler;\n                  Message message = messageEnvelope.message;\n                  mMessageEnvelopes.removeAt(0);\n                  mSendingMessage = true;\n                  mLock.unlock();\n\n#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS\n                  ALOGD(\"%p ~ pollOnce - sending message: handler=%p, what=%d\",\n                          this, handler.get(), message.what);\n#endif\n                  // 回调 native 层 handler 的 handleMessage\n                  handler->handleMessage(message);\n              } // release handler\n\n              mLock.lock();\n              mSendingMessage = false;\n              // 这里 result 就是把message回调给了handler\n              result = POLL_CALLBACK;\n          } else {\n              // The last message left at the head of the queue determines the next wakeup time.\n              // 设置下条消息到期的时间 并跳出循环等待Java层的下一次轮询\n              mNextMessageUptime = messageEnvelope.uptime;\n              break;\n          }\n      }\n\n      // Release lock.\n      mLock.unlock();\n\n      // Invoke all response callbacks.\n      for (size_t i = 0; i < mResponses.size(); i++) {\n          Response& response = mResponses.editItemAt(i);\n          if (response.request.ident == POLL_CALLBACK) {\n              int fd = response.request.fd;\n              int events = response.events;\n              void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS\n              ALOGD(\"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p\",\n                      this, response.request.callback.get(), fd, events, data);\n#endif\n              // Invoke the callback.  Note that the file descriptor may be closed by\n              // the callback (and potentially even reused) before the function returns so\n              // we need to be a little careful when removing the file descriptor afterwards.\n              int callbackResult = response.request.callback->handleEvent(fd, events, data);\n              if (callbackResult == 0) {\n                  AutoMutex _l(mLock);\n                  removeSequenceNumberLocked(response.seq);\n              }\n\n              // Clear the callback reference in the response structure promptly because we\n              // will not clear the response vector itself until the next poll.\n              response.request.callback.clear();\n              result = POLL_CALLBACK;\n          }\n      }\n      return result;\n}\n```\n\n\n总体流程其实就是 epoll_wait 拿到事件，处理事件并让 native 层的消息队列取一次消息。\n\n\n## **面试题**\n\n\n> 来自蔷神\n\n\n### **handler大致运转过程**\n\n\n`Handler#sendMessage` -> `MessageQueue#enqueueMessage` 消息入队 -> 如果消息入队时处于头部，或头部有同步屏障且插入的消息为最早的异步消息则唤醒 Looper `NativeMessageQueue#wake`\n\n\n\nLooper 被唤醒后轮询取消息，取到消息后看消息是否过期，如果没有过期就 pollOnce 等待至过期，过期了就出队发给 Handler，直到没有更多消息时 pollOnce 的过期时间被设置为 -1，无限期等待直到有新消息插入。\n\n\n### **handler消息类型以及每个类型的区别**\n\n\n同步消息，异步消息，同步屏障\n\n\n### **同步消息屏障的意义是什么? 通常用来干嘛?**\n\n\n其实比较类似一些异步任务调度机制的任务偷取（好像内核态的任务调度也有偷取这个机制？）\n\n\n\n在消息过多处理不过来的情况下优先处理异步消息，异步消息的异步其实指的就是不按消息队列中消息的顺序执行（毕竟在遇到屏障的时候只处理异步事件，不处理同步事件）\n\n\n\n同步屏障用完要记得撤销，不然就再也接收不到同步消息了\n\n\n### **如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?**\n\n\n那肯定不new，使用 `Message.obtain` 从对象池中拿取。如果发送消息都直接new的话会对堆内存造成较大负担，所以才有对象复用机制。\n\n\n### **idlehandler是什么**\n\n\nidlehandler 就是在消息队列取空或下一个消息需要等待时即将进入 pollOnce 等待之前回调的一个接口。\n\n\n```java\npublic static interface IdleHandler {\n    // 返回 false 就会在回调一次后移除\n    // 返回 true 则会一直保留\n    boolean queueIdle(); \n}\n```\n\n### **idlehandler可以用来做哪一类任务**\n\n\n执行优先级足够低的任务\n\n\n### **如果我频繁添加idlehandler是否发生anr**\n\n\n只要 idlehandler 中的处理没有耗时逻辑就不会，每次空闲执行的 idlehandler 不会超过4个。\n\n\n### **looper的loop是死循环会造成anr嘛？为什么**\n\n\n不会，因为 loop 进去有消息的时候会处理消息，没有消息的时候会进入 epoll 等待，anr 的原因在于没有及时处理消息。\n\n\n###  **ANR 的原因**\n - **系统进程(system_server)** 调度，设置定时监控（即埋下炸弹）\n\n - system_server 进程将任务派发到**应用进程**完成对消息的实际处理(执行任务)\n\n - 最后，执行任务时间过长，在定时器超时前 system_server 还**未收到任务完成的通知**，触发 ANR（炸弹爆炸）\n\n\n\n没有及时处理 system_server 派发的任务，system_server 没有收到任务完成的通知，就触发了 ANR。\n\n\n### **handler looper messagequeue是怎么个关系一对一还是一对多，多对多**\n\n\nLooper 跟 MessageQueue 是一对一的关系。MessageQueue 跟 Handler 是一对多的关系。\n\n\n### **looper和thread是一对一的关系是如何实现的**\n\n\n使用 ThreadLocal 保存 Looper 实例\n\n\n### **threadlocal是什么，有用过吗**\n\n\nThreadLocal 本质上是保存在 Thread 上面的一张 HashMap，不同之处在与它的键使用 WeakReference 存储，在 set 时会清理 key == null 的键值对。但用完的时候最好手动 remove，不然还是会内存泄漏。使用弱引用只是让 ThreadLocalMap 持有的 ThreadLocal 不会内存泄漏，ThreadLocal 对应的值还是会内存泄漏。\n\n\n### **messagequeue是什么数据结构**\n\n\n链表实现的优先队列\n\n\n### **延迟消息是如何实现的**\n\n\n消息队列是一个优先队列，插入时进行排序。插入时如果消息处于头部，且事件队列处于等待状态就唤醒它，Looper 拿了头部的消息就会 `pollOnce` 等待这个消息需要等待的时间后再将消息出队传递给 Handler。如果有队列顶部有同步屏障的话，最早的异步消息将会进行唤醒处理。\n\n\n","slug":"Handler Android 消息机制","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ullb0003fbsb0ona3ahw","content":"<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a><strong>解析</strong></h2><p>handler 源码也算是老生常谈了，之前也简单研究过源码。首先列出比较重要的几个类</p>\n<ul>\n<li><p>Handler</p>\n</li>\n<li><p>MessageQueue</p>\n</li>\n<li><p>Message</p>\n</li>\n<li><p>Looper</p>\n</li>\n</ul>\n<p>那么我们就从 Handler 最经典的用法开始分析</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handler = <span class=\"keyword\">object</span> : Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleMessage</span><span class=\"params\">(msg: <span class=\"type\">Message</span>)</span></span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">            setContentView(R.layout.activity_main)</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这里就有两个入口可以分析 <code>Handler#sendMessage</code>, <code>Handler#handleMessage</code></p>\n<h3 id=\"Handler-sendMessage\"><a href=\"#Handler-sendMessage\" class=\"headerlink\" title=\"Handler#sendMessage\"></a><strong>Handler#sendMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体实现看sendMessageDelay</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体实现看 sendMessageAtTime</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拿到字段里的 MessageQueue，然后 enqueueMessage</span></span><br><span class=\"line\"><span class=\"comment\">// 这个名字很容易猜到这是消息入队的操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">                <span class=\"built_in\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> MessageQueue queue, <span class=\"meta\">@NonNull</span> Message msg,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 msg 的 target 设置为 handler 自身，方便出队后拿到消息的发送者回调 handleMessage</span></span><br><span class=\"line\">    msg.target = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 workSourceUid</span></span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在new Handler的时候可以设置为异步，这样这个handler发送的消息都是异步消息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后我们就进入了 <code>MessageQueue#enqueueMessage</code></p>\n<h3 id=\"MessageQueue-enqueueMessage\"><a href=\"#MessageQueue-enqueueMessage\" class=\"headerlink\" title=\"MessageQueue#enqueueMessage\"></a><strong>MessageQueue#enqueueMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"type\">long</span> when)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 上锁，保证没有两条消息同时进行入队操作产生并发问题</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果这个 messgae 正在队列中，当然不能再次入队</span></span><br><span class=\"line\">        <span class=\"comment\">// 说一点小小的感悟吧，rust语言的移动语义可以让多次入队成为不可能，而在java中为了防范这种边界情况要写大量的检查代码。移动语义这个设计确实高明</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(msg + <span class=\"string\">&quot; This message is already in use.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果这个线程正在退出，当然不能给一条死掉的线程上的handler发消息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"type\">IllegalStateException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标记这个消息正在使用</span></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        <span class=\"comment\">// 设置这条信息应当从队列取出时的时间</span></span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到消息队列的头节点，没错，消息队列是一个链表结构</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"comment\">// 如果头节点为空 或者 when == 0 （意味着这个消息必须放置在头节点）或者 新插入的消息出队时间比头节点早</span></span><br><span class=\"line\">        <span class=\"comment\">// 就将插入的消息设置为新的头节点</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里可以看出消息队列是一个优先队列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            <span class=\"comment\">// 如果事件队列现在正处于等待状态就之后唤醒他 （其实就是唤醒epoll等待的事件线程）</span></span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 在队列的中间插入。通常我们不会唤醒这个事件队列除非队列的头部有一个同步屏障</span></span><br><span class=\"line\">            <span class=\"comment\">// 且这条消息是队列中最早的异步消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 正在阻塞 且 p.target == null 且 是异步消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果 p.target == null 则说明队列的头部是一条屏障消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"literal\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            <span class=\"comment\">// 经典算法题，双指针遍历链表</span></span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历到尾部或遍历到了自己应该待的地方 break 出去</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 如果触发这一行，说明这条消息不是最早的异步消息，那么就不需要唤醒了</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 插入</span></span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果需要唤醒就调用 nativeWake 进到 native 层对事件循环进行唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>激动人心的 native 之旅就要启程啦～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nativeWake</span><span class=\"params\">(<span class=\"type\">long</span> ptr)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"native-NativeMessageQueue-wake\"><a href=\"#native-NativeMessageQueue-wake\" class=\"headerlink\" title=\"native NativeMessageQueue#wake\"></a><strong>native NativeMessageQueue#wake</strong></h3><p>前往 <a href=\"http://aospxref.com/\">AOSPXRef</a> 查看源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">wake</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NativeMessageQueue::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mLooper-&gt;<span class=\"built_in\">wake</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这里可以看出 java 层传入的 mPtr 其实就是 native 层的 MessageQueue 的指针。并且 wake 方法实际上是调用了 <code>Looper#wake</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ wake&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// TEMP_FAILURE_RETRY 这个宏用于在系统调用失败时重试</span></span><br><span class=\"line\">    <span class=\"comment\">// 对 wakeEventFd 这个文件描述符写入唤醒信号 (1)，epoll IO 多路复用机制便会唤醒线程</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nWrite = <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">write</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;inc, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">    <span class=\"comment\">// 写入失败对应的异常处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nWrite != <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno != EAGAIN) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_ALWAYS_FATAL</span>(<span class=\"string\">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>, mWakeEventFd.<span class=\"built_in\">get</span>(), nWrite, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>可以看到我们向 mWakeEventFd 写入了唤醒信号，Looper 所对应线程上的 epoll 机制会停止等待唤醒信号，对线程进行唤醒。</p>\n<p>我们知道 epoll 是需要事先注册文件描述符的，找出这部分代码，我们继续分析</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::rebuildEpollLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Close old epoll instance if we have one.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_CALLBACKS</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        mEpollFd.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allocate the new epoll instance and register the WakeEventFd.</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll instance 并且注册 WakeEventFd</span></span><br><span class=\"line\">    mEpollFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class=\"line\">    <span class=\"built_in\">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class=\"number\">0</span>, <span class=\"string\">&quot;Could not create epoll instance: %s&quot;</span>, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 epoll 事件 wakeEvent</span></span><br><span class=\"line\">    epoll_event wakeEvent = <span class=\"built_in\">createEpollEvent</span>(EPOLLIN, WAKE_EVENT_FD_SEQ);</span><br><span class=\"line\">    <span class=\"comment\">// 注册文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;wakeEvent);</span><br><span class=\"line\">    <span class=\"built_in\">LOG_ALWAYS_FATAL_IF</span>(result != <span class=\"number\">0</span>, <span class=\"string\">&quot;Could not add wake event fd to epoll instance: %s&quot;</span>,</span><br><span class=\"line\">            <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册其他 epoll 事件：比如屏幕触摸事件，触摸屏幕时需要唤醒线程并在主线程回调 onTouch</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; [seq, request] : mRequests) &#123;</span><br><span class=\"line\">        epoll_event eventItem = <span class=\"built_in\">createEpollEvent</span>(request.<span class=\"built_in\">getEpollEvents</span>(), seq);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> epollResult = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (epollResult &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">ALOGE</span>(<span class=\"string\">&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;</span>,</span><br><span class=\"line\">                    request.fd, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>注册了之后，问题是在哪里进行 <code>epoll_wait</code> 等待呢？在这里先按下不表，我们从 <code>Handler#handleMessage</code> 开始分析。</p>\n<h3 id=\"Handler-handleMessage\"><a href=\"#Handler-handleMessage\" class=\"headerlink\" title=\"Handler#handleMessage\"></a><strong>Handler#handleMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handler#dispatchMessage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Looper-loopOnce\"><a href=\"#Looper-loopOnce\" class=\"headerlink\" title=\"Looper#loopOnce\"></a><strong>Looper#loopOnce</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper#loopOnce</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">loopOnce</span><span class=\"params\">(<span class=\"keyword\">final</span> Looper me,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> ident, <span class=\"keyword\">final</span> <span class=\"type\">int</span> thresholdOverride)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重要步骤，从队列中取出消息</span></span><br><span class=\"line\">    <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> me.mQueue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Printer</span> <span class=\"variable\">logging</span> <span class=\"operator\">=</span> me.mLogging;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logging != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                + msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个 Observer 可以在消息处理前和消息处理后做一些事情</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Observer</span> <span class=\"variable\">observer</span> <span class=\"operator\">=</span> sObserver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">traceTag</span> <span class=\"operator\">=</span> me.mTraceTag;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">slowDispatchThresholdMs</span> <span class=\"operator\">=</span> me.mSlowDispatchThresholdMs;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">slowDeliveryThresholdMs</span> <span class=\"operator\">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thresholdOverride &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        slowDispatchThresholdMs = thresholdOverride;</span><br><span class=\"line\">        slowDeliveryThresholdMs = thresholdOverride;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">logSlowDelivery</span> <span class=\"operator\">=</span> (slowDeliveryThresholdMs &gt; <span class=\"number\">0</span>) &amp;&amp; (msg.when &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">logSlowDispatch</span> <span class=\"operator\">=</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">needStartTime</span> <span class=\"operator\">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">needEndTime</span> <span class=\"operator\">=</span> logSlowDispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dispatchStart</span> <span class=\"operator\">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> dispatchEnd;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        token = observer.messageDispatchStarting();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">origWorkSource</span> <span class=\"operator\">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在这里把消息发给 Handler</span></span><br><span class=\"line\">        msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            observer.messageDispatched(token, msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Trace.traceEnd(traceTag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logSlowDelivery) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((dispatchStart - msg.when) &lt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">&quot;Drained&quot;</span>);</span><br><span class=\"line\">                me.mSlowDeliveryDetected = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class=\"string\">&quot;delivery&quot;</span>,</span><br><span class=\"line\">                        msg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class=\"line\">                me.mSlowDeliveryDetected = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logSlowDispatch) &#123;</span><br><span class=\"line\">        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class=\"string\">&quot;dispatch&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logging != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure that during the course of dispatching the</span></span><br><span class=\"line\">    <span class=\"comment\">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">newIdent</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ident != newIdent) &#123;</span><br><span class=\"line\">        Log.wtf(TAG, <span class=\"string\">&quot;Thread identity changed from 0x&quot;</span></span><br><span class=\"line\">                + Long.toHexString(ident) + <span class=\"string\">&quot; to 0x&quot;</span></span><br><span class=\"line\">                + Long.toHexString(newIdent) + <span class=\"string\">&quot; while dispatching to &quot;</span></span><br><span class=\"line\">                + msg.target.getClass().getName() + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                + msg.callback + <span class=\"string\">&quot; what=&quot;</span> + msg.what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消息已经用完了，清除状态放入实例池</span></span><br><span class=\"line\">    msg.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>别看上面一大堆代码，其实核心逻辑就是 <code>MessageQueue#next</code> 取出消息并把它分发给 <code>Handler</code>。其他的代码基本上就是单个消息处理太慢的警告机制。</p>\n<h3 id=\"Looper-loop\"><a href=\"#Looper-loop\" class=\"headerlink\" title=\"Looper#loop\"></a><strong>Looper#loop</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Looper</span> <span class=\"variable\">me</span> <span class=\"operator\">=</span> myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me.mInLoop) &#123;</span><br><span class=\"line\">        Slog.w(TAG, <span class=\"string\">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; before this one completed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    me.mInLoop = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ident</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class=\"line\">    <span class=\"comment\">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">thresholdOverride</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        SystemProperties.getInt(<span class=\"string\">&quot;log.looper.&quot;</span></span><br><span class=\"line\">                + Process.myUid() + <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">                + Thread.currentThread().getName()</span><br><span class=\"line\">                + <span class=\"string\">&quot;.slow&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    me.mSlowDeliveryDetected = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>重要代码也就是最后的死循环，这个死循环只会在 MessageQueue 正在退出的时候返回。</p>\n<h3 id=\"MessageQueue-next\"><a href=\"#MessageQueue-next\" class=\"headerlink\" title=\"MessageQueue#next\"></a><strong>MessageQueue#next</strong></h3><p>重头戏来了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ptr</span> <span class=\"operator\">=</span> mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里出现了 IdleHandler 的字眼</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pendingIdleHandlerCount</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nextPollTimeoutMillis</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// pollOnce 其实就是一个设置了超时时间的 epoll_wait</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">prevMsg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 消息队列的头部有同步屏障</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span> &amp;&amp; msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 找出队列中的首个异步消息</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"literal\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这个消息还没有到时间，设置一下下轮循环执行的 pollOnce 的超时时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"type\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 这个消息已经到时间了，从消息队列中取出返回</span></span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列空了，进入无限期的 epoll_wait 等待</span></span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 这里是 IdleHandler 相关的内容，先去看看 IdleHandler 这个东西怎么用</span></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一次空闲的时候，记录要运行的 idlehandler 的数量。</span></span><br><span class=\"line\">            <span class=\"comment\">// 空闲处理只在队列为空或第一条消息需要等待一段时间的时候执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 说白了就是在 pollOnce 之前执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"literal\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有 IdleHandler 的情况下单次循环在这里结束</span></span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                mBlocked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 最大只会执行4个 IdleHandler</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> <span class=\"title class_\">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">IdleHandler</span> <span class=\"variable\">idler</span> <span class=\"operator\">=</span> mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"literal\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">keep</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 执行</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不保留就删掉</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重制数量</span></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 执行了idleHandler就不等待了，因为可能在idleHandler中已经发送了新的消息，重走一遍流程</span></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"native-Looper-pollOnce\"><a href=\"#native-Looper-pollOnce\" class=\"headerlink\" title=\"native Looper#pollOnce\"></a><strong>native Looper#pollOnce</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollOnce</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis, <span class=\"type\">int</span>* outFd, <span class=\"type\">int</span>* outEvents, <span class=\"type\">void</span>** outData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (mResponseIndex &lt; mResponses.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">const</span> Response&amp; response = mResponses.<span class=\"built_in\">itemAt</span>(mResponseIndex++);</span><br><span class=\"line\">            <span class=\"type\">int</span> ident = response.request.ident;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ident &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> fd = response.request.fd;</span><br><span class=\"line\">                <span class=\"type\">int</span> events = response.events;</span><br><span class=\"line\">                <span class=\"type\">void</span>* data = response.request.data;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">                <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</span></span><br><span class=\"line\">                        <span class=\"string\">&quot;fd=%d, events=0x%x, data=%p&quot;</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>, ident, fd, events, data);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outFd != <span class=\"literal\">nullptr</span>) *outFd = fd;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outEvents != <span class=\"literal\">nullptr</span>) *outEvents = events;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outData != <span class=\"literal\">nullptr</span>) *outData = data;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ident;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// result != 0 时可以退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">            <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - returning result %d&quot;</span>, <span class=\"keyword\">this</span>, result);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outFd != <span class=\"literal\">nullptr</span>) *outFd = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outEvents != <span class=\"literal\">nullptr</span>) *outEvents = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outData != <span class=\"literal\">nullptr</span>) *outData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里如果返回0的话就要一直跑这个方法，不过我们知道pollInner实际上是不会返回的 (epoll_wait)</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以在这里猜测正常情况下返回就退出循环，只有在某些情况下需要重试?</span></span><br><span class=\"line\">        result = <span class=\"built_in\">pollInner</span>(timeoutMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来看看 pollInner，东西真多，我们只关注重点代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;</span>, <span class=\"keyword\">this</span>, timeoutMillis);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Adjust the timeout based on when the next message is due.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeoutMillis != <span class=\"number\">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class=\"line\">        <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"type\">int</span> messageTimeoutMillis = <span class=\"built_in\">toMillisecondTimeoutDelay</span>(now, mNextMessageUptime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageTimeoutMillis &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (timeoutMillis &lt; <span class=\"number\">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class=\"line\">            timeoutMillis = messageTimeoutMillis;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - next message in %&quot;</span> PRId64 <span class=\"string\">&quot;ns, adjusted timeout: timeoutMillis=%d&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mNextMessageUptime - now, timeoutMillis);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Poll.</span></span><br><span class=\"line\">    <span class=\"comment\">// result的取值有四种: POLL_WAKE = -1 POLL_CALLBACK = -2 POLL_TIMEOUT = -3 POLL_ERROR = -4</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    mResponses.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    mResponseIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We are about to idle.</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建事件集合eventItems，EPOLL_MAX_EVENTS=16</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 调用epoll_wait()来等待事件，如果有事件，就放入事件集合eventItems中，并返回事件数量，如果没有，就一直等，超时时间为我们传入的timeoutMillis</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No longer idling.</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Acquire lock.</span></span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    mLock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Rebuild epoll set if needed.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollRebuildRequired) &#123;</span><br><span class=\"line\">        mEpollRebuildRequired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">rebuildEpollLocked</span>();</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for poll error.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果发生的事件小于0，说明 epoll_wait 出异常了，设置 result 为 POLL_ERROR 后跳转到 Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Poll failed with an unexpected error: %s&quot;</span>, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        result = POLL_ERROR;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for poll timeout.</span></span><br><span class=\"line\">    <span class=\"comment\">// epoll_wait 超时返回，跳转到 Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - timeout&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        result = POLL_TIMEOUT;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle all events.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - handling events from %d fds&quot;</span>, <span class=\"keyword\">this</span>, eventCount);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 走到这里说明有事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 挨个取出事件进行响应</span></span><br><span class=\"line\">        <span class=\"type\">const</span> SequenceNumber seq = eventItems[i].data.u64;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"comment\">// 是 wake event</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (seq == WAKE_EVENT_FD_SEQ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 清除 wakeEventFd 的事件循环计数器，以便接收下一次事件</span></span><br><span class=\"line\">                <span class=\"comment\">// 事件文件描述符（如 eventfd）被设置为边缘触发（ET）模式。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这意味着只有在状态发生变化时，epoll 才会返回这个文件描述符的事件。</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果你不读取这个事件，状态就不会改变，所以 epoll 可能不会再次返回这个事件，即使有新的唤醒事件发生。</span></span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 响应其他事件</span></span><br><span class=\"line\">            <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; request_it = mRequests.<span class=\"built_in\">find</span>(seq);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request_it != mRequests.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; request = request_it-&gt;second;</span><br><span class=\"line\">                <span class=\"type\">int</span> events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class=\"line\">                mResponses.<span class=\"built_in\">push</span>(&#123;.seq = seq, .events = events, .request = request&#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Ignoring unexpected epoll events 0x%x for sequence number %&quot;</span> PRIu64</span><br><span class=\"line\">                        <span class=\"string\">&quot; that is no longer registered.&quot;</span>,</span><br><span class=\"line\">                        epollEvents, seq);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Invoke pending message callbacks.</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里就是处理 native 层的消息，跟 java 层 handler 的逻辑差不多</span></span><br><span class=\"line\">      <span class=\"comment\">// native 层的消息是用 vector 存的</span></span><br><span class=\"line\">      mNextMessageUptime = LLONG_MAX;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (mMessageEnvelopes.<span class=\"built_in\">size</span>() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">          <span class=\"type\">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.<span class=\"built_in\">itemAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 消息到期</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// Remove the envelope from the list.</span></span><br><span class=\"line\">              <span class=\"comment\">// We keep a strong reference to the handler until the call to handleMessage</span></span><br><span class=\"line\">              <span class=\"comment\">// finishes.  Then we drop it so that the handler can be deleted *before*</span></span><br><span class=\"line\">              <span class=\"comment\">// we reacquire our lock.</span></span><br><span class=\"line\">              &#123; <span class=\"comment\">// obtain handler</span></span><br><span class=\"line\">                  sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class=\"line\">                  Message message = messageEnvelope.message;</span><br><span class=\"line\">                  mMessageEnvelopes.<span class=\"built_in\">removeAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">                  mSendingMessage = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                  mLock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class=\"line\">                  <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;</span>,</span><br><span class=\"line\">                          <span class=\"keyword\">this</span>, handler.<span class=\"built_in\">get</span>(), message.what);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                  <span class=\"comment\">// 回调 native 层 handler 的 handleMessage</span></span><br><span class=\"line\">                  handler-&gt;<span class=\"built_in\">handleMessage</span>(message);</span><br><span class=\"line\">              &#125; <span class=\"comment\">// release handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">              mLock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">              mSendingMessage = <span class=\"literal\">false</span>;</span><br><span class=\"line\">              <span class=\"comment\">// 这里 result 就是把message回调给了handler</span></span><br><span class=\"line\">              result = POLL_CALLBACK;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class=\"line\">              <span class=\"comment\">// 设置下条消息到期的时间 并跳出循环等待Java层的下一次轮询</span></span><br><span class=\"line\">              mNextMessageUptime = messageEnvelope.uptime;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Release lock.</span></span><br><span class=\"line\">      mLock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Invoke all response callbacks.</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; mResponses.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">          Response&amp; response = mResponses.<span class=\"built_in\">editItemAt</span>(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class=\"line\">              <span class=\"type\">int</span> fd = response.request.fd;</span><br><span class=\"line\">              <span class=\"type\">int</span> events = response.events;</span><br><span class=\"line\">              <span class=\"type\">void</span>* data = response.request.data;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class=\"line\">              <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;</span>,</span><br><span class=\"line\">                      <span class=\"keyword\">this</span>, response.request.callback.<span class=\"built_in\">get</span>(), fd, events, data);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">              <span class=\"comment\">// Invoke the callback.  Note that the file descriptor may be closed by</span></span><br><span class=\"line\">              <span class=\"comment\">// the callback (and potentially even reused) before the function returns so</span></span><br><span class=\"line\">              <span class=\"comment\">// we need to be a little careful when removing the file descriptor afterwards.</span></span><br><span class=\"line\">              <span class=\"type\">int</span> callbackResult = response.request.callback-&gt;<span class=\"built_in\">handleEvent</span>(fd, events, data);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (callbackResult == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                  AutoMutex _l(mLock);</span><br><span class=\"line\">                  <span class=\"built_in\">removeSequenceNumberLocked</span>(response.seq);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// Clear the callback reference in the response structure promptly because we</span></span><br><span class=\"line\">              <span class=\"comment\">// will not clear the response vector itself until the next poll.</span></span><br><span class=\"line\">              response.request.callback.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">              result = POLL_CALLBACK;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>总体流程其实就是 epoll_wait 拿到事件，处理事件并让 native 层的消息队列取一次消息。</p>\n<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a><strong>面试题</strong></h2><blockquote>\n<p>来自蔷神</p>\n</blockquote>\n<h3 id=\"handler大致运转过程\"><a href=\"#handler大致运转过程\" class=\"headerlink\" title=\"handler大致运转过程\"></a><strong>handler大致运转过程</strong></h3><p><code>Handler#sendMessage</code> -&gt; <code>MessageQueue#enqueueMessage</code> 消息入队 -&gt; 如果消息入队时处于头部，或头部有同步屏障且插入的消息为最早的异步消息则唤醒 Looper <code>NativeMessageQueue#wake</code></p>\n<p>Looper 被唤醒后轮询取消息，取到消息后看消息是否过期，如果没有过期就 pollOnce 等待至过期，过期了就出队发给 Handler，直到没有更多消息时 pollOnce 的过期时间被设置为 -1，无限期等待直到有新消息插入。</p>\n<h3 id=\"handler消息类型以及每个类型的区别\"><a href=\"#handler消息类型以及每个类型的区别\" class=\"headerlink\" title=\"handler消息类型以及每个类型的区别\"></a><strong>handler消息类型以及每个类型的区别</strong></h3><p>同步消息，异步消息，同步屏障</p>\n<h3 id=\"同步消息屏障的意义是什么-通常用来干嘛\"><a href=\"#同步消息屏障的意义是什么-通常用来干嘛\" class=\"headerlink\" title=\"同步消息屏障的意义是什么? 通常用来干嘛?\"></a><strong>同步消息屏障的意义是什么? 通常用来干嘛?</strong></h3><p>其实比较类似一些异步任务调度机制的任务偷取（好像内核态的任务调度也有偷取这个机制？）</p>\n<p>在消息过多处理不过来的情况下优先处理异步消息，异步消息的异步其实指的就是不按消息队列中消息的顺序执行（毕竟在遇到屏障的时候只处理异步事件，不处理同步事件）</p>\n<p>同步屏障用完要记得撤销，不然就再也接收不到同步消息了</p>\n<h3 id=\"如果我要发送handler消息，是直接new嘛-为什么不这样？这样会造成什么影响\"><a href=\"#如果我要发送handler消息，是直接new嘛-为什么不这样？这样会造成什么影响\" class=\"headerlink\" title=\"如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?\"></a><strong>如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?</strong></h3><p>那肯定不new，使用 <code>Message.obtain</code> 从对象池中拿取。如果发送消息都直接new的话会对堆内存造成较大负担，所以才有对象复用机制。</p>\n<h3 id=\"idlehandler是什么\"><a href=\"#idlehandler是什么\" class=\"headerlink\" title=\"idlehandler是什么\"></a><strong>idlehandler是什么</strong></h3><p>idlehandler 就是在消息队列取空或下一个消息需要等待时即将进入 pollOnce 等待之前回调的一个接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdleHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 false 就会在回调一次后移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回 true 则会一直保留</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">queueIdle</span><span class=\"params\">()</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"idlehandler可以用来做哪一类任务\"><a href=\"#idlehandler可以用来做哪一类任务\" class=\"headerlink\" title=\"idlehandler可以用来做哪一类任务\"></a><strong>idlehandler可以用来做哪一类任务</strong></h3><p>执行优先级足够低的任务</p>\n<h3 id=\"如果我频繁添加idlehandler是否发生anr\"><a href=\"#如果我频繁添加idlehandler是否发生anr\" class=\"headerlink\" title=\"如果我频繁添加idlehandler是否发生anr\"></a><strong>如果我频繁添加idlehandler是否发生anr</strong></h3><p>只要 idlehandler 中的处理没有耗时逻辑就不会，每次空闲执行的 idlehandler 不会超过4个。</p>\n<h3 id=\"looper的loop是死循环会造成anr嘛？为什么\"><a href=\"#looper的loop是死循环会造成anr嘛？为什么\" class=\"headerlink\" title=\"looper的loop是死循环会造成anr嘛？为什么\"></a><strong>looper的loop是死循环会造成anr嘛？为什么</strong></h3><p>不会，因为 loop 进去有消息的时候会处理消息，没有消息的时候会进入 epoll 等待，anr 的原因在于没有及时处理消息。</p>\n<h3 id=\"ANR-的原因\"><a href=\"#ANR-的原因\" class=\"headerlink\" title=\"ANR 的原因\"></a><strong>ANR 的原因</strong></h3><ul>\n<li><p><strong>系统进程(system_server)</strong> 调度，设置定时监控（即埋下炸弹）</p>\n</li>\n<li><p>system_server 进程将任务派发到<strong>应用进程</strong>完成对消息的实际处理(执行任务)</p>\n</li>\n<li><p>最后，执行任务时间过长，在定时器超时前 system_server 还<strong>未收到任务完成的通知</strong>，触发 ANR（炸弹爆炸）</p>\n</li>\n</ul>\n<p>没有及时处理 system_server 派发的任务，system_server 没有收到任务完成的通知，就触发了 ANR。</p>\n<h3 id=\"handler-looper-messagequeue是怎么个关系一对一还是一对多，多对多\"><a href=\"#handler-looper-messagequeue是怎么个关系一对一还是一对多，多对多\" class=\"headerlink\" title=\"handler looper messagequeue是怎么个关系一对一还是一对多，多对多\"></a><strong>handler looper messagequeue是怎么个关系一对一还是一对多，多对多</strong></h3><p>Looper 跟 MessageQueue 是一对一的关系。MessageQueue 跟 Handler 是一对多的关系。</p>\n<h3 id=\"looper和thread是一对一的关系是如何实现的\"><a href=\"#looper和thread是一对一的关系是如何实现的\" class=\"headerlink\" title=\"looper和thread是一对一的关系是如何实现的\"></a><strong>looper和thread是一对一的关系是如何实现的</strong></h3><p>使用 ThreadLocal 保存 Looper 实例</p>\n<h3 id=\"threadlocal是什么，有用过吗\"><a href=\"#threadlocal是什么，有用过吗\" class=\"headerlink\" title=\"threadlocal是什么，有用过吗\"></a><strong>threadlocal是什么，有用过吗</strong></h3><p>ThreadLocal 本质上是保存在 Thread 上面的一张 HashMap，不同之处在与它的键使用 WeakReference 存储，在 set 时会清理 key &#x3D;&#x3D; null 的键值对。但用完的时候最好手动 remove，不然还是会内存泄漏。使用弱引用只是让 ThreadLocalMap 持有的 ThreadLocal 不会内存泄漏，ThreadLocal 对应的值还是会内存泄漏。</p>\n<h3 id=\"messagequeue是什么数据结构\"><a href=\"#messagequeue是什么数据结构\" class=\"headerlink\" title=\"messagequeue是什么数据结构\"></a><strong>messagequeue是什么数据结构</strong></h3><p>链表实现的优先队列</p>\n<h3 id=\"延迟消息是如何实现的\"><a href=\"#延迟消息是如何实现的\" class=\"headerlink\" title=\"延迟消息是如何实现的\"></a><strong>延迟消息是如何实现的</strong></h3><p>消息队列是一个优先队列，插入时进行排序。插入时如果消息处于头部，且事件队列处于等待状态就唤醒它，Looper 拿了头部的消息就会 <code>pollOnce</code> 等待这个消息需要等待的时间后再将消息出队传递给 Handler。如果有队列顶部有同步屏障的话，最早的异步消息将会进行唤醒处理。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a><strong>解析</strong></h2><p>handler 源码也算是老生常谈了，之前也简单研究过源码。首先列出比较重要的几个类</p>\n<ul>\n<li><p>Handler</p>\n</li>\n<li><p>MessageQueue</p>\n</li>\n<li><p>Message</p>\n</li>\n<li><p>Looper</p>\n</li>\n</ul>\n<p>那么我们就从 Handler 最经典的用法开始分析</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> handler = <span class=\"keyword\">object</span> : Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handleMessage</span><span class=\"params\">(msg: <span class=\"type\">Message</span>)</span></span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">            setContentView(R.layout.activity_main)</span><br><span class=\"line\">            handler.sendEmptyMessage(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这里就有两个入口可以分析 <code>Handler#sendMessage</code>, <code>Handler#handleMessage</code></p>\n<h3 id=\"Handler-sendMessage\"><a href=\"#Handler-sendMessage\" class=\"headerlink\" title=\"Handler#sendMessage\"></a><strong>Handler#sendMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体实现看sendMessageDelay</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体实现看 sendMessageAtTime</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拿到字段里的 MessageQueue，然后 enqueueMessage</span></span><br><span class=\"line\"><span class=\"comment\">// 这个名字很容易猜到这是消息入队的操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">                <span class=\"built_in\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> MessageQueue queue, <span class=\"meta\">@NonNull</span> Message msg,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 msg 的 target 设置为 handler 自身，方便出队后拿到消息的发送者回调 handleMessage</span></span><br><span class=\"line\">    msg.target = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 workSourceUid</span></span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在new Handler的时候可以设置为异步，这样这个handler发送的消息都是异步消息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>然后我们就进入了 <code>MessageQueue#enqueueMessage</code></p>\n<h3 id=\"MessageQueue-enqueueMessage\"><a href=\"#MessageQueue-enqueueMessage\" class=\"headerlink\" title=\"MessageQueue#enqueueMessage\"></a><strong>MessageQueue#enqueueMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"type\">long</span> when)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 上锁，保证没有两条消息同时进行入队操作产生并发问题</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果这个 messgae 正在队列中，当然不能再次入队</span></span><br><span class=\"line\">        <span class=\"comment\">// 说一点小小的感悟吧，rust语言的移动语义可以让多次入队成为不可能，而在java中为了防范这种边界情况要写大量的检查代码。移动语义这个设计确实高明</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(msg + <span class=\"string\">&quot; This message is already in use.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果这个线程正在退出，当然不能给一条死掉的线程上的handler发消息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"type\">IllegalStateException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标记这个消息正在使用</span></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        <span class=\"comment\">// 设置这条信息应当从队列取出时的时间</span></span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到消息队列的头节点，没错，消息队列是一个链表结构</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"comment\">// 如果头节点为空 或者 when == 0 （意味着这个消息必须放置在头节点）或者 新插入的消息出队时间比头节点早</span></span><br><span class=\"line\">        <span class=\"comment\">// 就将插入的消息设置为新的头节点</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里可以看出消息队列是一个优先队列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            <span class=\"comment\">// 如果事件队列现在正处于等待状态就之后唤醒他 （其实就是唤醒epoll等待的事件线程）</span></span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 在队列的中间插入。通常我们不会唤醒这个事件队列除非队列的头部有一个同步屏障</span></span><br><span class=\"line\">            <span class=\"comment\">// 且这条消息是队列中最早的异步消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 正在阻塞 且 p.target == null 且 是异步消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果 p.target == null 则说明队列的头部是一条屏障消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"literal\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            <span class=\"comment\">// 经典算法题，双指针遍历链表</span></span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历到尾部或遍历到了自己应该待的地方 break 出去</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 如果触发这一行，说明这条消息不是最早的异步消息，那么就不需要唤醒了</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 插入</span></span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果需要唤醒就调用 nativeWake 进到 native 层对事件循环进行唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>激动人心的 native 之旅就要启程啦～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nativeWake</span><span class=\"params\">(<span class=\"type\">long</span> ptr)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"native-NativeMessageQueue-wake\"><a href=\"#native-NativeMessageQueue-wake\" class=\"headerlink\" title=\"native NativeMessageQueue#wake\"></a><strong>native NativeMessageQueue#wake</strong></h3><p>前往 <a href=\"http://aospxref.com/\">AOSPXRef</a> 查看源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">wake</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NativeMessageQueue::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mLooper-&gt;<span class=\"built_in\">wake</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这里可以看出 java 层传入的 mPtr 其实就是 native 层的 MessageQueue 的指针。并且 wake 方法实际上是调用了 <code>Looper#wake</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ wake&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// TEMP_FAILURE_RETRY 这个宏用于在系统调用失败时重试</span></span><br><span class=\"line\">    <span class=\"comment\">// 对 wakeEventFd 这个文件描述符写入唤醒信号 (1)，epoll IO 多路复用机制便会唤醒线程</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nWrite = <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">write</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;inc, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">    <span class=\"comment\">// 写入失败对应的异常处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nWrite != <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno != EAGAIN) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOG_ALWAYS_FATAL</span>(<span class=\"string\">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>, mWakeEventFd.<span class=\"built_in\">get</span>(), nWrite, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>可以看到我们向 mWakeEventFd 写入了唤醒信号，Looper 所对应线程上的 epoll 机制会停止等待唤醒信号，对线程进行唤醒。</p>\n<p>我们知道 epoll 是需要事先注册文件描述符的，找出这部分代码，我们继续分析</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::rebuildEpollLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Close old epoll instance if we have one.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_CALLBACKS</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        mEpollFd.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allocate the new epoll instance and register the WakeEventFd.</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配新的 epoll instance 并且注册 WakeEventFd</span></span><br><span class=\"line\">    mEpollFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class=\"line\">    <span class=\"built_in\">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class=\"number\">0</span>, <span class=\"string\">&quot;Could not create epoll instance: %s&quot;</span>, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 epoll 事件 wakeEvent</span></span><br><span class=\"line\">    epoll_event wakeEvent = <span class=\"built_in\">createEpollEvent</span>(EPOLLIN, WAKE_EVENT_FD_SEQ);</span><br><span class=\"line\">    <span class=\"comment\">// 注册文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;wakeEvent);</span><br><span class=\"line\">    <span class=\"built_in\">LOG_ALWAYS_FATAL_IF</span>(result != <span class=\"number\">0</span>, <span class=\"string\">&quot;Could not add wake event fd to epoll instance: %s&quot;</span>,</span><br><span class=\"line\">            <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册其他 epoll 事件：比如屏幕触摸事件，触摸屏幕时需要唤醒线程并在主线程回调 onTouch</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; [seq, request] : mRequests) &#123;</span><br><span class=\"line\">        epoll_event eventItem = <span class=\"built_in\">createEpollEvent</span>(request.<span class=\"built_in\">getEpollEvents</span>(), seq);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> epollResult = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (epollResult &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">ALOGE</span>(<span class=\"string\">&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;</span>,</span><br><span class=\"line\">                    request.fd, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>注册了之后，问题是在哪里进行 <code>epoll_wait</code> 等待呢？在这里先按下不表，我们从 <code>Handler#handleMessage</code> 开始分析。</p>\n<h3 id=\"Handler-handleMessage\"><a href=\"#Handler-handleMessage\" class=\"headerlink\" title=\"Handler#handleMessage\"></a><strong>Handler#handleMessage</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handler#dispatchMessage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Looper-loopOnce\"><a href=\"#Looper-loopOnce\" class=\"headerlink\" title=\"Looper#loopOnce\"></a><strong>Looper#loopOnce</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Looper#loopOnce</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">loopOnce</span><span class=\"params\">(<span class=\"keyword\">final</span> Looper me,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> ident, <span class=\"keyword\">final</span> <span class=\"type\">int</span> thresholdOverride)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重要步骤，从队列中取出消息</span></span><br><span class=\"line\">    <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> me.mQueue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Printer</span> <span class=\"variable\">logging</span> <span class=\"operator\">=</span> me.mLogging;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logging != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                + msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个 Observer 可以在消息处理前和消息处理后做一些事情</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Observer</span> <span class=\"variable\">observer</span> <span class=\"operator\">=</span> sObserver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">traceTag</span> <span class=\"operator\">=</span> me.mTraceTag;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">slowDispatchThresholdMs</span> <span class=\"operator\">=</span> me.mSlowDispatchThresholdMs;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">slowDeliveryThresholdMs</span> <span class=\"operator\">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thresholdOverride &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        slowDispatchThresholdMs = thresholdOverride;</span><br><span class=\"line\">        slowDeliveryThresholdMs = thresholdOverride;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">logSlowDelivery</span> <span class=\"operator\">=</span> (slowDeliveryThresholdMs &gt; <span class=\"number\">0</span>) &amp;&amp; (msg.when &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">logSlowDispatch</span> <span class=\"operator\">=</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">needStartTime</span> <span class=\"operator\">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">needEndTime</span> <span class=\"operator\">=</span> logSlowDispatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">dispatchStart</span> <span class=\"operator\">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> dispatchEnd;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        token = observer.messageDispatchStarting();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">origWorkSource</span> <span class=\"operator\">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在这里把消息发给 Handler</span></span><br><span class=\"line\">        msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            observer.messageDispatched(token, msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (observer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Trace.traceEnd(traceTag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logSlowDelivery) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((dispatchStart - msg.when) &lt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">&quot;Drained&quot;</span>);</span><br><span class=\"line\">                me.mSlowDeliveryDetected = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class=\"string\">&quot;delivery&quot;</span>,</span><br><span class=\"line\">                        msg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class=\"line\">                me.mSlowDeliveryDetected = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logSlowDispatch) &#123;</span><br><span class=\"line\">        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class=\"string\">&quot;dispatch&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logging != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure that during the course of dispatching the</span></span><br><span class=\"line\">    <span class=\"comment\">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">newIdent</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ident != newIdent) &#123;</span><br><span class=\"line\">        Log.wtf(TAG, <span class=\"string\">&quot;Thread identity changed from 0x&quot;</span></span><br><span class=\"line\">                + Long.toHexString(ident) + <span class=\"string\">&quot; to 0x&quot;</span></span><br><span class=\"line\">                + Long.toHexString(newIdent) + <span class=\"string\">&quot; while dispatching to &quot;</span></span><br><span class=\"line\">                + msg.target.getClass().getName() + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                + msg.callback + <span class=\"string\">&quot; what=&quot;</span> + msg.what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消息已经用完了，清除状态放入实例池</span></span><br><span class=\"line\">    msg.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>别看上面一大堆代码，其实核心逻辑就是 <code>MessageQueue#next</code> 取出消息并把它分发给 <code>Handler</code>。其他的代码基本上就是单个消息处理太慢的警告机制。</p>\n<h3 id=\"Looper-loop\"><a href=\"#Looper-loop\" class=\"headerlink\" title=\"Looper#loop\"></a><strong>Looper#loop</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Looper</span> <span class=\"variable\">me</span> <span class=\"operator\">=</span> myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me.mInLoop) &#123;</span><br><span class=\"line\">        Slog.w(TAG, <span class=\"string\">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; before this one completed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    me.mInLoop = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ident</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class=\"line\">    <span class=\"comment\">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">thresholdOverride</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        SystemProperties.getInt(<span class=\"string\">&quot;log.looper.&quot;</span></span><br><span class=\"line\">                + Process.myUid() + <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">                + Thread.currentThread().getName()</span><br><span class=\"line\">                + <span class=\"string\">&quot;.slow&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    me.mSlowDeliveryDetected = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>重要代码也就是最后的死循环，这个死循环只会在 MessageQueue 正在退出的时候返回。</p>\n<h3 id=\"MessageQueue-next\"><a href=\"#MessageQueue-next\" class=\"headerlink\" title=\"MessageQueue#next\"></a><strong>MessageQueue#next</strong></h3><p>重头戏来了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ptr</span> <span class=\"operator\">=</span> mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里出现了 IdleHandler 的字眼</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pendingIdleHandlerCount</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nextPollTimeoutMillis</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// pollOnce 其实就是一个设置了超时时间的 epoll_wait</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">prevMsg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 消息队列的头部有同步屏障</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span> &amp;&amp; msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 找出队列中的首个异步消息</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"literal\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果有消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这个消息还没有到时间，设置一下下轮循环执行的 pollOnce 的超时时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"type\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 这个消息已经到时间了，从消息队列中取出返回</span></span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 队列空了，进入无限期的 epoll_wait 等待</span></span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 这里是 IdleHandler 相关的内容，先去看看 IdleHandler 这个东西怎么用</span></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一次空闲的时候，记录要运行的 idlehandler 的数量。</span></span><br><span class=\"line\">            <span class=\"comment\">// 空闲处理只在队列为空或第一条消息需要等待一段时间的时候执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 说白了就是在 pollOnce 之前执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"literal\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有 IdleHandler 的情况下单次循环在这里结束</span></span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                mBlocked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 最大只会执行4个 IdleHandler</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> <span class=\"title class_\">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">IdleHandler</span> <span class=\"variable\">idler</span> <span class=\"operator\">=</span> mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"literal\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">keep</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 执行</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不保留就删掉</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重制数量</span></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 执行了idleHandler就不等待了，因为可能在idleHandler中已经发送了新的消息，重走一遍流程</span></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"native-Looper-pollOnce\"><a href=\"#native-Looper-pollOnce\" class=\"headerlink\" title=\"native Looper#pollOnce\"></a><strong>native Looper#pollOnce</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollOnce</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis, <span class=\"type\">int</span>* outFd, <span class=\"type\">int</span>* outEvents, <span class=\"type\">void</span>** outData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (mResponseIndex &lt; mResponses.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">const</span> Response&amp; response = mResponses.<span class=\"built_in\">itemAt</span>(mResponseIndex++);</span><br><span class=\"line\">            <span class=\"type\">int</span> ident = response.request.ident;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ident &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> fd = response.request.fd;</span><br><span class=\"line\">                <span class=\"type\">int</span> events = response.events;</span><br><span class=\"line\">                <span class=\"type\">void</span>* data = response.request.data;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">                <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</span></span><br><span class=\"line\">                        <span class=\"string\">&quot;fd=%d, events=0x%x, data=%p&quot;</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>, ident, fd, events, data);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outFd != <span class=\"literal\">nullptr</span>) *outFd = fd;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outEvents != <span class=\"literal\">nullptr</span>) *outEvents = events;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outData != <span class=\"literal\">nullptr</span>) *outData = data;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ident;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// result != 0 时可以退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">            <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - returning result %d&quot;</span>, <span class=\"keyword\">this</span>, result);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outFd != <span class=\"literal\">nullptr</span>) *outFd = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outEvents != <span class=\"literal\">nullptr</span>) *outEvents = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (outData != <span class=\"literal\">nullptr</span>) *outData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里如果返回0的话就要一直跑这个方法，不过我们知道pollInner实际上是不会返回的 (epoll_wait)</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以在这里猜测正常情况下返回就退出循环，只有在某些情况下需要重试?</span></span><br><span class=\"line\">        result = <span class=\"built_in\">pollInner</span>(timeoutMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>接下来看看 pollInner，东西真多，我们只关注重点代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;</span>, <span class=\"keyword\">this</span>, timeoutMillis);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Adjust the timeout based on when the next message is due.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeoutMillis != <span class=\"number\">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class=\"line\">        <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"type\">int</span> messageTimeoutMillis = <span class=\"built_in\">toMillisecondTimeoutDelay</span>(now, mNextMessageUptime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageTimeoutMillis &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (timeoutMillis &lt; <span class=\"number\">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class=\"line\">            timeoutMillis = messageTimeoutMillis;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - next message in %&quot;</span> PRId64 <span class=\"string\">&quot;ns, adjusted timeout: timeoutMillis=%d&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mNextMessageUptime - now, timeoutMillis);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Poll.</span></span><br><span class=\"line\">    <span class=\"comment\">// result的取值有四种: POLL_WAKE = -1 POLL_CALLBACK = -2 POLL_TIMEOUT = -3 POLL_ERROR = -4</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    mResponses.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    mResponseIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We are about to idle.</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建事件集合eventItems，EPOLL_MAX_EVENTS=16</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 调用epoll_wait()来等待事件，如果有事件，就放入事件集合eventItems中，并返回事件数量，如果没有，就一直等，超时时间为我们传入的timeoutMillis</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No longer idling.</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Acquire lock.</span></span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    mLock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Rebuild epoll set if needed.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollRebuildRequired) &#123;</span><br><span class=\"line\">        mEpollRebuildRequired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">rebuildEpollLocked</span>();</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for poll error.</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果发生的事件小于0，说明 epoll_wait 出异常了，设置 result 为 POLL_ERROR 后跳转到 Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Poll failed with an unexpected error: %s&quot;</span>, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">        result = POLL_ERROR;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for poll timeout.</span></span><br><span class=\"line\">    <span class=\"comment\">// epoll_wait 超时返回，跳转到 Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">        <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - timeout&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        result = POLL_TIMEOUT;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle all events.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class=\"line\">    <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - handling events from %d fds&quot;</span>, <span class=\"keyword\">this</span>, eventCount);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 走到这里说明有事件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 挨个取出事件进行响应</span></span><br><span class=\"line\">        <span class=\"type\">const</span> SequenceNumber seq = eventItems[i].data.u64;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"comment\">// 是 wake event</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (seq == WAKE_EVENT_FD_SEQ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 清除 wakeEventFd 的事件循环计数器，以便接收下一次事件</span></span><br><span class=\"line\">                <span class=\"comment\">// 事件文件描述符（如 eventfd）被设置为边缘触发（ET）模式。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这意味着只有在状态发生变化时，epoll 才会返回这个文件描述符的事件。</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果你不读取这个事件，状态就不会改变，所以 epoll 可能不会再次返回这个事件，即使有新的唤醒事件发生。</span></span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 响应其他事件</span></span><br><span class=\"line\">            <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; request_it = mRequests.<span class=\"built_in\">find</span>(seq);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request_it != mRequests.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; request = request_it-&gt;second;</span><br><span class=\"line\">                <span class=\"type\">int</span> events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class=\"line\">                mResponses.<span class=\"built_in\">push</span>(&#123;.seq = seq, .events = events, .request = request&#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">ALOGW</span>(<span class=\"string\">&quot;Ignoring unexpected epoll events 0x%x for sequence number %&quot;</span> PRIu64</span><br><span class=\"line\">                        <span class=\"string\">&quot; that is no longer registered.&quot;</span>,</span><br><span class=\"line\">                        epollEvents, seq);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Invoke pending message callbacks.</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里就是处理 native 层的消息，跟 java 层 handler 的逻辑差不多</span></span><br><span class=\"line\">      <span class=\"comment\">// native 层的消息是用 vector 存的</span></span><br><span class=\"line\">      mNextMessageUptime = LLONG_MAX;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (mMessageEnvelopes.<span class=\"built_in\">size</span>() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">          <span class=\"type\">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.<span class=\"built_in\">itemAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 消息到期</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// Remove the envelope from the list.</span></span><br><span class=\"line\">              <span class=\"comment\">// We keep a strong reference to the handler until the call to handleMessage</span></span><br><span class=\"line\">              <span class=\"comment\">// finishes.  Then we drop it so that the handler can be deleted *before*</span></span><br><span class=\"line\">              <span class=\"comment\">// we reacquire our lock.</span></span><br><span class=\"line\">              &#123; <span class=\"comment\">// obtain handler</span></span><br><span class=\"line\">                  sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class=\"line\">                  Message message = messageEnvelope.message;</span><br><span class=\"line\">                  mMessageEnvelopes.<span class=\"built_in\">removeAt</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">                  mSendingMessage = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                  mLock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class=\"line\">                  <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;</span>,</span><br><span class=\"line\">                          <span class=\"keyword\">this</span>, handler.<span class=\"built_in\">get</span>(), message.what);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">                  <span class=\"comment\">// 回调 native 层 handler 的 handleMessage</span></span><br><span class=\"line\">                  handler-&gt;<span class=\"built_in\">handleMessage</span>(message);</span><br><span class=\"line\">              &#125; <span class=\"comment\">// release handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">              mLock.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">              mSendingMessage = <span class=\"literal\">false</span>;</span><br><span class=\"line\">              <span class=\"comment\">// 这里 result 就是把message回调给了handler</span></span><br><span class=\"line\">              result = POLL_CALLBACK;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class=\"line\">              <span class=\"comment\">// 设置下条消息到期的时间 并跳出循环等待Java层的下一次轮询</span></span><br><span class=\"line\">              mNextMessageUptime = messageEnvelope.uptime;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Release lock.</span></span><br><span class=\"line\">      mLock.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Invoke all response callbacks.</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; mResponses.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">          Response&amp; response = mResponses.<span class=\"built_in\">editItemAt</span>(i);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class=\"line\">              <span class=\"type\">int</span> fd = response.request.fd;</span><br><span class=\"line\">              <span class=\"type\">int</span> events = response.events;</span><br><span class=\"line\">              <span class=\"type\">void</span>* data = response.request.data;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class=\"line\">              <span class=\"built_in\">ALOGD</span>(<span class=\"string\">&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;</span>,</span><br><span class=\"line\">                      <span class=\"keyword\">this</span>, response.request.callback.<span class=\"built_in\">get</span>(), fd, events, data);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">              <span class=\"comment\">// Invoke the callback.  Note that the file descriptor may be closed by</span></span><br><span class=\"line\">              <span class=\"comment\">// the callback (and potentially even reused) before the function returns so</span></span><br><span class=\"line\">              <span class=\"comment\">// we need to be a little careful when removing the file descriptor afterwards.</span></span><br><span class=\"line\">              <span class=\"type\">int</span> callbackResult = response.request.callback-&gt;<span class=\"built_in\">handleEvent</span>(fd, events, data);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (callbackResult == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                  AutoMutex _l(mLock);</span><br><span class=\"line\">                  <span class=\"built_in\">removeSequenceNumberLocked</span>(response.seq);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// Clear the callback reference in the response structure promptly because we</span></span><br><span class=\"line\">              <span class=\"comment\">// will not clear the response vector itself until the next poll.</span></span><br><span class=\"line\">              response.request.callback.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">              result = POLL_CALLBACK;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>总体流程其实就是 epoll_wait 拿到事件，处理事件并让 native 层的消息队列取一次消息。</p>\n<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a><strong>面试题</strong></h2><blockquote>\n<p>来自蔷神</p>\n</blockquote>\n<h3 id=\"handler大致运转过程\"><a href=\"#handler大致运转过程\" class=\"headerlink\" title=\"handler大致运转过程\"></a><strong>handler大致运转过程</strong></h3><p><code>Handler#sendMessage</code> -&gt; <code>MessageQueue#enqueueMessage</code> 消息入队 -&gt; 如果消息入队时处于头部，或头部有同步屏障且插入的消息为最早的异步消息则唤醒 Looper <code>NativeMessageQueue#wake</code></p>\n<p>Looper 被唤醒后轮询取消息，取到消息后看消息是否过期，如果没有过期就 pollOnce 等待至过期，过期了就出队发给 Handler，直到没有更多消息时 pollOnce 的过期时间被设置为 -1，无限期等待直到有新消息插入。</p>\n<h3 id=\"handler消息类型以及每个类型的区别\"><a href=\"#handler消息类型以及每个类型的区别\" class=\"headerlink\" title=\"handler消息类型以及每个类型的区别\"></a><strong>handler消息类型以及每个类型的区别</strong></h3><p>同步消息，异步消息，同步屏障</p>\n<h3 id=\"同步消息屏障的意义是什么-通常用来干嘛\"><a href=\"#同步消息屏障的意义是什么-通常用来干嘛\" class=\"headerlink\" title=\"同步消息屏障的意义是什么? 通常用来干嘛?\"></a><strong>同步消息屏障的意义是什么? 通常用来干嘛?</strong></h3><p>其实比较类似一些异步任务调度机制的任务偷取（好像内核态的任务调度也有偷取这个机制？）</p>\n<p>在消息过多处理不过来的情况下优先处理异步消息，异步消息的异步其实指的就是不按消息队列中消息的顺序执行（毕竟在遇到屏障的时候只处理异步事件，不处理同步事件）</p>\n<p>同步屏障用完要记得撤销，不然就再也接收不到同步消息了</p>\n<h3 id=\"如果我要发送handler消息，是直接new嘛-为什么不这样？这样会造成什么影响\"><a href=\"#如果我要发送handler消息，是直接new嘛-为什么不这样？这样会造成什么影响\" class=\"headerlink\" title=\"如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?\"></a><strong>如果我要发送handler消息，是直接new嘛? 为什么不这样？这样会造成什么影响?</strong></h3><p>那肯定不new，使用 <code>Message.obtain</code> 从对象池中拿取。如果发送消息都直接new的话会对堆内存造成较大负担，所以才有对象复用机制。</p>\n<h3 id=\"idlehandler是什么\"><a href=\"#idlehandler是什么\" class=\"headerlink\" title=\"idlehandler是什么\"></a><strong>idlehandler是什么</strong></h3><p>idlehandler 就是在消息队列取空或下一个消息需要等待时即将进入 pollOnce 等待之前回调的一个接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IdleHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 false 就会在回调一次后移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回 true 则会一直保留</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">queueIdle</span><span class=\"params\">()</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"idlehandler可以用来做哪一类任务\"><a href=\"#idlehandler可以用来做哪一类任务\" class=\"headerlink\" title=\"idlehandler可以用来做哪一类任务\"></a><strong>idlehandler可以用来做哪一类任务</strong></h3><p>执行优先级足够低的任务</p>\n<h3 id=\"如果我频繁添加idlehandler是否发生anr\"><a href=\"#如果我频繁添加idlehandler是否发生anr\" class=\"headerlink\" title=\"如果我频繁添加idlehandler是否发生anr\"></a><strong>如果我频繁添加idlehandler是否发生anr</strong></h3><p>只要 idlehandler 中的处理没有耗时逻辑就不会，每次空闲执行的 idlehandler 不会超过4个。</p>\n<h3 id=\"looper的loop是死循环会造成anr嘛？为什么\"><a href=\"#looper的loop是死循环会造成anr嘛？为什么\" class=\"headerlink\" title=\"looper的loop是死循环会造成anr嘛？为什么\"></a><strong>looper的loop是死循环会造成anr嘛？为什么</strong></h3><p>不会，因为 loop 进去有消息的时候会处理消息，没有消息的时候会进入 epoll 等待，anr 的原因在于没有及时处理消息。</p>\n<h3 id=\"ANR-的原因\"><a href=\"#ANR-的原因\" class=\"headerlink\" title=\"ANR 的原因\"></a><strong>ANR 的原因</strong></h3><ul>\n<li><p><strong>系统进程(system_server)</strong> 调度，设置定时监控（即埋下炸弹）</p>\n</li>\n<li><p>system_server 进程将任务派发到<strong>应用进程</strong>完成对消息的实际处理(执行任务)</p>\n</li>\n<li><p>最后，执行任务时间过长，在定时器超时前 system_server 还<strong>未收到任务完成的通知</strong>，触发 ANR（炸弹爆炸）</p>\n</li>\n</ul>\n<p>没有及时处理 system_server 派发的任务，system_server 没有收到任务完成的通知，就触发了 ANR。</p>\n<h3 id=\"handler-looper-messagequeue是怎么个关系一对一还是一对多，多对多\"><a href=\"#handler-looper-messagequeue是怎么个关系一对一还是一对多，多对多\" class=\"headerlink\" title=\"handler looper messagequeue是怎么个关系一对一还是一对多，多对多\"></a><strong>handler looper messagequeue是怎么个关系一对一还是一对多，多对多</strong></h3><p>Looper 跟 MessageQueue 是一对一的关系。MessageQueue 跟 Handler 是一对多的关系。</p>\n<h3 id=\"looper和thread是一对一的关系是如何实现的\"><a href=\"#looper和thread是一对一的关系是如何实现的\" class=\"headerlink\" title=\"looper和thread是一对一的关系是如何实现的\"></a><strong>looper和thread是一对一的关系是如何实现的</strong></h3><p>使用 ThreadLocal 保存 Looper 实例</p>\n<h3 id=\"threadlocal是什么，有用过吗\"><a href=\"#threadlocal是什么，有用过吗\" class=\"headerlink\" title=\"threadlocal是什么，有用过吗\"></a><strong>threadlocal是什么，有用过吗</strong></h3><p>ThreadLocal 本质上是保存在 Thread 上面的一张 HashMap，不同之处在与它的键使用 WeakReference 存储，在 set 时会清理 key &#x3D;&#x3D; null 的键值对。但用完的时候最好手动 remove，不然还是会内存泄漏。使用弱引用只是让 ThreadLocalMap 持有的 ThreadLocal 不会内存泄漏，ThreadLocal 对应的值还是会内存泄漏。</p>\n<h3 id=\"messagequeue是什么数据结构\"><a href=\"#messagequeue是什么数据结构\" class=\"headerlink\" title=\"messagequeue是什么数据结构\"></a><strong>messagequeue是什么数据结构</strong></h3><p>链表实现的优先队列</p>\n<h3 id=\"延迟消息是如何实现的\"><a href=\"#延迟消息是如何实现的\" class=\"headerlink\" title=\"延迟消息是如何实现的\"></a><strong>延迟消息是如何实现的</strong></h3><p>消息队列是一个优先队列，插入时进行排序。插入时如果消息处于头部，且事件队列处于等待状态就唤醒它，Looper 拿了头部的消息就会 <code>pollOnce</code> 等待这个消息需要等待的时间后再将消息出队传递给 Handler。如果有队列顶部有同步屏障的话，最早的异步消息将会进行唤醒处理。</p>\n"},{"title":"virtual-memory-for-user-applications","urlname":"Ro5td2HZloi6YzxPcKrc9aHbn9d","date":"2023-10-20T11:21:16.000Z","updated":"2024-01-18T09:29:35.000Z","_content":"> MIT 6.s081 lecture 17 个人总结笔记\n\n\n\n参考:\n\n\n- https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans\n\n- https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf\n\n\n\n之前我们知道，virtual memory 的 page fault 已经被内核玩出了花。进程 fork 的 COW 机制，虚拟内存页表的驱除机制等等，都是利用了 page fault 这个机制实现的。page fault 很好用，那么我们能不能让用户程序也利用上 page fault 呢？\n\n\n\n为了让用户程序有效的利用上 page fault 机制，操作系统内核需要向用户程序提供一系列原语（primitives）：\n\n\n- Prot1 降低单个 page 的 accessibility (mprotect)\n\n- ProtN  降低 N 个 page 的 accessibility，之所以单独提出是因为保护多个 page 的平均开销更小 （只需要刷新一次 TLB）(mprotect)\n\n- Unprot 解除单个 page 的保护 (mprotect)\n\n- Dirty 查看一个 page 是否为 dirty page\n\n- map2 使得一个应用程序可以将一个特定的物理内存地址空间映射两次，并且这两次映射拥有不同的accessability (mmap)\n\n\n\n有了这些原语，用户程序就可以利用 page fault 的机制做一些更好的优化。\n\n\n## **eg.1 构建大的缓存表**\n\n\n我们可以用设计虚拟内存驱除机制的思路，利用上面提到的操作系统提供的一系列原语使用有限的虚拟内存构建一个非常大的缓存表。\n\n\n\n下面提供一个比较极端的代码示例——只使用一页虚拟内存实现的缓存表\n\n\n![image](./images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png)\n\n![image](./images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png)\n\n![image](./images/M3ECbky79odXDkxrPwkc4hO4n3d.png)\n\n![image](./images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png)\n\n## **eg.2 Baker’s Real-Time Copying Garbage Collector**\n\n\n> 以前背过一些关于 GC 的 Java 八股文，没想到会在这里再接触到这个话题\n\n\n\n我们先讨论一种特定的 copying GC，假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个空间，其中一个是from空间，另一个是to空间。Copying GC 的基本思想是将仍然在使用的对象从 from 空间复制到 to 空间。在 to 空间满时进行翻转。至于如何识别对象是否在使用可以使用可达性分析算法。\n\n\n\n背过 java 八股文的人就知道，我们希望尽可能缩短 copy 所花的时间，因为这段时间我们需要 stop the world。那么我们可不可以将 copy 所花费的时间成本均摊一下，不让程序触发 GC 后突兀的停顿很长一段时间？\n\n\n\n我们可以使用设计 COW 的思路来做这件事，触发 GC 时我们只 copy GC root，将时间成本降到最低。然后我们将 GC root 标记为 unscanned （使用 prot 原语降低其可见性），在我们下次访问 GC root 时就会触发 page fault，进入到我们设置的 page fault handler。在 page fault handler 中将当前页中的地址指向的页也 copy 到 to space，对指针进行 forwarding （就是将指针的指向从原本在 from space 的内存转发到 to space 的内存），并且将其标记为 unscanned。然后我们将扫描过的页标记为 scanned（也就是对其进行 unprot 操作）。这样我们就成功的将 GC 的时间成本分摊到了程序读写虚拟内存的时候。\n\n\n\n但是既然用户程序不能访问，访问了会导致 page fault，那 GC 线程要怎么访问呢？当然我们可以在 page fault handler 中使用 unprot 操作，但是这样做的话会导致并发的问题（在 GC 线程 unprot 后其他用户线程访问了这块内存）。所以我们需要 map2 原语，将一块物理内存映射到两块虚拟内存地址，一块供 GC 线程读写（可读写），一块供用户线程读写（unscanned的情况下不可读写）。这样便完美的解决了这个问题，同时我们获得了天然的并发性：因为 unscanned 状态下 GC 线程读写内存时用户线程无法读写这块内存内存，而 scanned 状态下用户线程读写内存时 GC 线程不会读写这块内存。\n\n\n\n[MIT的教授们用 C 语言代码言简意骇的实现了这种 GC](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans/17.7-shi-yong-xu-ni-nei-cun-te-xing-de-gc-dai-ma-zhan-shi)\n\n\n\n\n","source":"_posts/virtual-memory-for-user-applications.md","raw":"---\ntitle: virtual-memory-for-user-applications\nurlname: Ro5td2HZloi6YzxPcKrc9aHbn9d\ndate: 2023-10-20T19:21:16.000Z\nupdated: '2024-01-18 17:29:35'\ntags:\n  - xv6\n  - 公开课\n  - MIT6.s081\n  - 操作系统\n  - 虚拟内存\ncategories: 笔记\n---\n> MIT 6.s081 lecture 17 个人总结笔记\n\n\n\n参考:\n\n\n- https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans\n\n- https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf\n\n\n\n之前我们知道，virtual memory 的 page fault 已经被内核玩出了花。进程 fork 的 COW 机制，虚拟内存页表的驱除机制等等，都是利用了 page fault 这个机制实现的。page fault 很好用，那么我们能不能让用户程序也利用上 page fault 呢？\n\n\n\n为了让用户程序有效的利用上 page fault 机制，操作系统内核需要向用户程序提供一系列原语（primitives）：\n\n\n- Prot1 降低单个 page 的 accessibility (mprotect)\n\n- ProtN  降低 N 个 page 的 accessibility，之所以单独提出是因为保护多个 page 的平均开销更小 （只需要刷新一次 TLB）(mprotect)\n\n- Unprot 解除单个 page 的保护 (mprotect)\n\n- Dirty 查看一个 page 是否为 dirty page\n\n- map2 使得一个应用程序可以将一个特定的物理内存地址空间映射两次，并且这两次映射拥有不同的accessability (mmap)\n\n\n\n有了这些原语，用户程序就可以利用 page fault 的机制做一些更好的优化。\n\n\n## **eg.1 构建大的缓存表**\n\n\n我们可以用设计虚拟内存驱除机制的思路，利用上面提到的操作系统提供的一系列原语使用有限的虚拟内存构建一个非常大的缓存表。\n\n\n\n下面提供一个比较极端的代码示例——只使用一页虚拟内存实现的缓存表\n\n\n![image](./images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png)\n\n![image](./images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png)\n\n![image](./images/M3ECbky79odXDkxrPwkc4hO4n3d.png)\n\n![image](./images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png)\n\n## **eg.2 Baker’s Real-Time Copying Garbage Collector**\n\n\n> 以前背过一些关于 GC 的 Java 八股文，没想到会在这里再接触到这个话题\n\n\n\n我们先讨论一种特定的 copying GC，假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个空间，其中一个是from空间，另一个是to空间。Copying GC 的基本思想是将仍然在使用的对象从 from 空间复制到 to 空间。在 to 空间满时进行翻转。至于如何识别对象是否在使用可以使用可达性分析算法。\n\n\n\n背过 java 八股文的人就知道，我们希望尽可能缩短 copy 所花的时间，因为这段时间我们需要 stop the world。那么我们可不可以将 copy 所花费的时间成本均摊一下，不让程序触发 GC 后突兀的停顿很长一段时间？\n\n\n\n我们可以使用设计 COW 的思路来做这件事，触发 GC 时我们只 copy GC root，将时间成本降到最低。然后我们将 GC root 标记为 unscanned （使用 prot 原语降低其可见性），在我们下次访问 GC root 时就会触发 page fault，进入到我们设置的 page fault handler。在 page fault handler 中将当前页中的地址指向的页也 copy 到 to space，对指针进行 forwarding （就是将指针的指向从原本在 from space 的内存转发到 to space 的内存），并且将其标记为 unscanned。然后我们将扫描过的页标记为 scanned（也就是对其进行 unprot 操作）。这样我们就成功的将 GC 的时间成本分摊到了程序读写虚拟内存的时候。\n\n\n\n但是既然用户程序不能访问，访问了会导致 page fault，那 GC 线程要怎么访问呢？当然我们可以在 page fault handler 中使用 unprot 操作，但是这样做的话会导致并发的问题（在 GC 线程 unprot 后其他用户线程访问了这块内存）。所以我们需要 map2 原语，将一块物理内存映射到两块虚拟内存地址，一块供 GC 线程读写（可读写），一块供用户线程读写（unscanned的情况下不可读写）。这样便完美的解决了这个问题，同时我们获得了天然的并发性：因为 unscanned 状态下 GC 线程读写内存时用户线程无法读写这块内存内存，而 scanned 状态下用户线程读写内存时 GC 线程不会读写这块内存。\n\n\n\n[MIT的教授们用 C 语言代码言简意骇的实现了这种 GC](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans/17.7-shi-yong-xu-ni-nei-cun-te-xing-de-gc-dai-ma-zhan-shi)\n\n\n\n\n","slug":"virtual-memory-for-user-applications","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ullc0004fbsbb7ag7wil","content":"<blockquote>\n<p>MIT 6.s081 lecture 17 个人总结笔记</p>\n</blockquote>\n<p>参考:</p>\n<ul>\n<li><p><a href=\"https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans\">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans</a></p>\n</li>\n<li><p><a href=\"https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf\">https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf</a></p>\n</li>\n</ul>\n<p>之前我们知道，virtual memory 的 page fault 已经被内核玩出了花。进程 fork 的 COW 机制，虚拟内存页表的驱除机制等等，都是利用了 page fault 这个机制实现的。page fault 很好用，那么我们能不能让用户程序也利用上 page fault 呢？</p>\n<p>为了让用户程序有效的利用上 page fault 机制，操作系统内核需要向用户程序提供一系列原语（primitives）：</p>\n<ul>\n<li><p>Prot1 降低单个 page 的 accessibility (mprotect)</p>\n</li>\n<li><p>ProtN  降低 N 个 page 的 accessibility，之所以单独提出是因为保护多个 page 的平均开销更小 （只需要刷新一次 TLB）(mprotect)</p>\n</li>\n<li><p>Unprot 解除单个 page 的保护 (mprotect)</p>\n</li>\n<li><p>Dirty 查看一个 page 是否为 dirty page</p>\n</li>\n<li><p>map2 使得一个应用程序可以将一个特定的物理内存地址空间映射两次，并且这两次映射拥有不同的accessability (mmap)</p>\n</li>\n</ul>\n<p>有了这些原语，用户程序就可以利用 page fault 的机制做一些更好的优化。</p>\n<h2 id=\"eg-1-构建大的缓存表\"><a href=\"#eg-1-构建大的缓存表\" class=\"headerlink\" title=\"eg.1 构建大的缓存表\"></a><strong>eg.1 构建大的缓存表</strong></h2><p>我们可以用设计虚拟内存驱除机制的思路，利用上面提到的操作系统提供的一系列原语使用有限的虚拟内存构建一个非常大的缓存表。</p>\n<p>下面提供一个比较极端的代码示例——只使用一页虚拟内存实现的缓存表</p>\n<p><img src=\"/./images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png\" alt=\"image\"></p>\n<p><img src=\"/./images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png\" alt=\"image\"></p>\n<p><img src=\"/./images/M3ECbky79odXDkxrPwkc4hO4n3d.png\" alt=\"image\"></p>\n<p><img src=\"/./images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png\" alt=\"image\"></p>\n<h2 id=\"eg-2-Baker’s-Real-Time-Copying-Garbage-Collector\"><a href=\"#eg-2-Baker’s-Real-Time-Copying-Garbage-Collector\" class=\"headerlink\" title=\"eg.2 Baker’s Real-Time Copying Garbage Collector\"></a><strong>eg.2 Baker’s Real-Time Copying Garbage Collector</strong></h2><blockquote>\n<p>以前背过一些关于 GC 的 Java 八股文，没想到会在这里再接触到这个话题</p>\n</blockquote>\n<p>我们先讨论一种特定的 copying GC，假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个空间，其中一个是from空间，另一个是to空间。Copying GC 的基本思想是将仍然在使用的对象从 from 空间复制到 to 空间。在 to 空间满时进行翻转。至于如何识别对象是否在使用可以使用可达性分析算法。</p>\n<p>背过 java 八股文的人就知道，我们希望尽可能缩短 copy 所花的时间，因为这段时间我们需要 stop the world。那么我们可不可以将 copy 所花费的时间成本均摊一下，不让程序触发 GC 后突兀的停顿很长一段时间？</p>\n<p>我们可以使用设计 COW 的思路来做这件事，触发 GC 时我们只 copy GC root，将时间成本降到最低。然后我们将 GC root 标记为 unscanned （使用 prot 原语降低其可见性），在我们下次访问 GC root 时就会触发 page fault，进入到我们设置的 page fault handler。在 page fault handler 中将当前页中的地址指向的页也 copy 到 to space，对指针进行 forwarding （就是将指针的指向从原本在 from space 的内存转发到 to space 的内存），并且将其标记为 unscanned。然后我们将扫描过的页标记为 scanned（也就是对其进行 unprot 操作）。这样我们就成功的将 GC 的时间成本分摊到了程序读写虚拟内存的时候。</p>\n<p>但是既然用户程序不能访问，访问了会导致 page fault，那 GC 线程要怎么访问呢？当然我们可以在 page fault handler 中使用 unprot 操作，但是这样做的话会导致并发的问题（在 GC 线程 unprot 后其他用户线程访问了这块内存）。所以我们需要 map2 原语，将一块物理内存映射到两块虚拟内存地址，一块供 GC 线程读写（可读写），一块供用户线程读写（unscanned的情况下不可读写）。这样便完美的解决了这个问题，同时我们获得了天然的并发性：因为 unscanned 状态下 GC 线程读写内存时用户线程无法读写这块内存内存，而 scanned 状态下用户线程读写内存时 GC 线程不会读写这块内存。</p>\n<p><a href=\"https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans/17.7-shi-yong-xu-ni-nei-cun-te-xing-de-gc-dai-ma-zhan-shi\">MIT的教授们用 C 语言代码言简意骇的实现了这种 GC</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>MIT 6.s081 lecture 17 个人总结笔记</p>\n</blockquote>\n<p>参考:</p>\n<ul>\n<li><p><a href=\"https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans\">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans</a></p>\n</li>\n<li><p><a href=\"https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf\">https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf</a></p>\n</li>\n</ul>\n<p>之前我们知道，virtual memory 的 page fault 已经被内核玩出了花。进程 fork 的 COW 机制，虚拟内存页表的驱除机制等等，都是利用了 page fault 这个机制实现的。page fault 很好用，那么我们能不能让用户程序也利用上 page fault 呢？</p>\n<p>为了让用户程序有效的利用上 page fault 机制，操作系统内核需要向用户程序提供一系列原语（primitives）：</p>\n<ul>\n<li><p>Prot1 降低单个 page 的 accessibility (mprotect)</p>\n</li>\n<li><p>ProtN  降低 N 个 page 的 accessibility，之所以单独提出是因为保护多个 page 的平均开销更小 （只需要刷新一次 TLB）(mprotect)</p>\n</li>\n<li><p>Unprot 解除单个 page 的保护 (mprotect)</p>\n</li>\n<li><p>Dirty 查看一个 page 是否为 dirty page</p>\n</li>\n<li><p>map2 使得一个应用程序可以将一个特定的物理内存地址空间映射两次，并且这两次映射拥有不同的accessability (mmap)</p>\n</li>\n</ul>\n<p>有了这些原语，用户程序就可以利用 page fault 的机制做一些更好的优化。</p>\n<h2 id=\"eg-1-构建大的缓存表\"><a href=\"#eg-1-构建大的缓存表\" class=\"headerlink\" title=\"eg.1 构建大的缓存表\"></a><strong>eg.1 构建大的缓存表</strong></h2><p>我们可以用设计虚拟内存驱除机制的思路，利用上面提到的操作系统提供的一系列原语使用有限的虚拟内存构建一个非常大的缓存表。</p>\n<p>下面提供一个比较极端的代码示例——只使用一页虚拟内存实现的缓存表</p>\n<p><img src=\"/./images/HHCzb2S1eoJIwOxYKkjcQAzRnrY.png\" alt=\"image\"></p>\n<p><img src=\"/./images/HNkJb2c3KoNEwjxUN09cvEXjn2f.png\" alt=\"image\"></p>\n<p><img src=\"/./images/M3ECbky79odXDkxrPwkc4hO4n3d.png\" alt=\"image\"></p>\n<p><img src=\"/./images/UJuvbnwDHo4ltYxm4kzcVE4xnCg.png\" alt=\"image\"></p>\n<h2 id=\"eg-2-Baker’s-Real-Time-Copying-Garbage-Collector\"><a href=\"#eg-2-Baker’s-Real-Time-Copying-Garbage-Collector\" class=\"headerlink\" title=\"eg.2 Baker’s Real-Time Copying Garbage Collector\"></a><strong>eg.2 Baker’s Real-Time Copying Garbage Collector</strong></h2><blockquote>\n<p>以前背过一些关于 GC 的 Java 八股文，没想到会在这里再接触到这个话题</p>\n</blockquote>\n<p>我们先讨论一种特定的 copying GC，假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个空间，其中一个是from空间，另一个是to空间。Copying GC 的基本思想是将仍然在使用的对象从 from 空间复制到 to 空间。在 to 空间满时进行翻转。至于如何识别对象是否在使用可以使用可达性分析算法。</p>\n<p>背过 java 八股文的人就知道，我们希望尽可能缩短 copy 所花的时间，因为这段时间我们需要 stop the world。那么我们可不可以将 copy 所花费的时间成本均摊一下，不让程序触发 GC 后突兀的停顿很长一段时间？</p>\n<p>我们可以使用设计 COW 的思路来做这件事，触发 GC 时我们只 copy GC root，将时间成本降到最低。然后我们将 GC root 标记为 unscanned （使用 prot 原语降低其可见性），在我们下次访问 GC root 时就会触发 page fault，进入到我们设置的 page fault handler。在 page fault handler 中将当前页中的地址指向的页也 copy 到 to space，对指针进行 forwarding （就是将指针的指向从原本在 from space 的内存转发到 to space 的内存），并且将其标记为 unscanned。然后我们将扫描过的页标记为 scanned（也就是对其进行 unprot 操作）。这样我们就成功的将 GC 的时间成本分摊到了程序读写虚拟内存的时候。</p>\n<p>但是既然用户程序不能访问，访问了会导致 page fault，那 GC 线程要怎么访问呢？当然我们可以在 page fault handler 中使用 unprot 操作，但是这样做的话会导致并发的问题（在 GC 线程 unprot 后其他用户线程访问了这块内存）。所以我们需要 map2 原语，将一块物理内存映射到两块虚拟内存地址，一块供 GC 线程读写（可读写），一块供用户线程读写（unscanned的情况下不可读写）。这样便完美的解决了这个问题，同时我们获得了天然的并发性：因为 unscanned 状态下 GC 线程读写内存时用户线程无法读写这块内存内存，而 scanned 状态下用户线程读写内存时 GC 线程不会读写这块内存。</p>\n<p><a href=\"https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec17-virtual-memory-for-applications-frans/17.7-shi-yong-xu-ni-nei-cun-te-xing-de-gc-dai-ma-zhan-shi\">MIT的教授们用 C 语言代码言简意骇的实现了这种 GC</a></p>\n"},{"title":"xv6-fs","urlname":"RLSwdlgCRo68xTxoNn6caCU1nRh","date":"2023-10-17T13:09:23.000Z","updated":"2024-01-18T09:32:05.000Z","_content":"> 下文中没有具体说明的场景均描述 xv6 文件系统的实现\n\n\n\n好吧 我们就来详细捋一捋 fs\n\n\n## **组成**\n\n\n// todo\n\n\n## **事务 Transaction**\n\n\n> 事务在用数据库的时候就已经经常用到了，但是没想到文件系统也有事务。从文件系统的事务实现中我们也可以管中窥豹数据库的事务是怎么实现的，数据库的 crash recovery 是如何保证的。\n\n\n### **xv6**\n\n\n事务的作用是保证一组磁盘写操作的原子性 （即要么全部完成，要么全部失败)，从而支持 crash recovery。事务是我们对一组整体具有原子性的磁盘写操作的抽象，而我们是如何实现事务这个特性的呢？\n\n\n\n当然是凭借日志系统。在xv6中，我们在执行一组磁盘写操作时，会先将这组写操作发到 block cache。block cache 就是磁盘 block 在内存中的 copy。\n\n\n\n在write系统调用的最后（也就是事务结束时），这些更新都被从 block cache 拷贝到了 log 中，之后会更新 header block 的计数来表明当前的 transaction 已经结束了。\n\n\n\n更新 header block 的计数这个操作是一个原子操作（得益于硬件支持），被称为 commit point。如果系统在 commit point 之前崩溃，则相当于事务在执行时中断，我们便放弃之前已有的全部更改。但如果系统在 commit point 之后崩溃，则相当于事务已经执行完毕（但是还没有回收）。虽然此时 log 中的变更还没有写入到磁盘对应的位置，但是即使在此时崩溃重启时也可以根据 log 中的记录恢复之前的更改。\n\n\n\ncommit point 之后当然是将 log 中的变更写回磁盘，然后清除 header block 中的计数（计数清除被视作释放了一个事务），至此一个事务的流程完成。\n\n\n### **ext3**\n\n\next3 是在真实世界中使用的一种文件系统实现，直到现在也仍然经常在 linux 上使用。我们可以轻易的在 linux 上以 ext3 文件系统的格式挂载一块硬盘：\n\n\n```bash\nsudo vim /etc/fstab # 在文件末尾加上 /dev/<设备> <要挂载的路径> ext3 defaults 1 1\n```\n\n\next3 的实现思路是基于 [Journaling the Linux ext2fs Filesystem](https://pdos.csail.mit.edu/6.828/2020/readings/journal-design.pdf) 中描述的一种高性能高可靠文件系统实现。其实现方式跟 xv6 的文件系统实现有很多类似的地方，不过因为其用于现实世界，所以比 xv6 考虑了更多细节，且总体上性能要更好（好得多）：\n\n\n- ext3 提供了异步系统调用 ，即系统修改完 block cache 就直接返回（是的，ext3 上的 write 系统调用返回时数据其实还没有被写到磁盘上，在这个中途 crash 事务是有可能回滚的）\n\n- ext3 支持批处理 (batching) ，即 ext3 可以合并一段时间内的所有事务，最后将其作为一个大事务进行提交，这样做整体只会向磁盘中写入一次数据。\n\t- 首先批处理减少了事务带来的开销，从机械硬盘中查找log的位置实际上开销不小，而批处理合并了多个事务，减少了事务执行的次数。\n\t\t- 如果之前的多个事务中都修改了同一个block，批处理后写入磁盘时就只需要写入一次 (这种情况被称作 write absorbing)，相当于减少了磁盘 io。\n\t\t- 批处理利好 disk scheduling\n\t\t- 磁盘的读写也是具有局部性的，一次性的向磁盘的连续位置写入1000个block，要比分1000次每次写一个不同位置的磁盘block快得多。写log就是向磁盘的连续位置写block。通过向磁盘提交大批量的写操作，可以更加的高效。\n\t\t\t- 如果能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新block的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得disk scheduling。这是batching带来的另一个好处。\n\t\t\n- 良好的并发性能 concurrency\n\t- ext3 允许并行写操作，在一个总的事务提交之前，其他 write 系统调用不必等待到当前事务执行完毕，而是直接让 write 操作合并到当前事务当中。\n\t\t- 可以有不同的 transaction 同时存在，尽管只有一个 open transaction 可以接收系统调用。\n\t\t- 一个 open transaction\n\t\t\t- 若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的open transaction中进行。\n\t\t\t- 若干个正在从cache中向文件系统block写数据的transaction\n\t\t\t- 若干个正在被释放的transaction，这个并不占用太多的工作\n\t\t\t- 也就是说 提交事务 ，写入磁盘，释放事务 这三个操作都是异步的。\n\t\t\n\n\n\n","source":"_posts/xv6-fs.md","raw":"---\ntitle: xv6-fs\nurlname: RLSwdlgCRo68xTxoNn6caCU1nRh\ndate: 2023-10-17T21:09:23.000Z\nupdated: '2024-01-18 17:32:05'\ntags:\n  - 公开课\n  - MIT6.s081\n  - File System\n  - xv6\ncategories: 笔记\n---\n> 下文中没有具体说明的场景均描述 xv6 文件系统的实现\n\n\n\n好吧 我们就来详细捋一捋 fs\n\n\n## **组成**\n\n\n// todo\n\n\n## **事务 Transaction**\n\n\n> 事务在用数据库的时候就已经经常用到了，但是没想到文件系统也有事务。从文件系统的事务实现中我们也可以管中窥豹数据库的事务是怎么实现的，数据库的 crash recovery 是如何保证的。\n\n\n### **xv6**\n\n\n事务的作用是保证一组磁盘写操作的原子性 （即要么全部完成，要么全部失败)，从而支持 crash recovery。事务是我们对一组整体具有原子性的磁盘写操作的抽象，而我们是如何实现事务这个特性的呢？\n\n\n\n当然是凭借日志系统。在xv6中，我们在执行一组磁盘写操作时，会先将这组写操作发到 block cache。block cache 就是磁盘 block 在内存中的 copy。\n\n\n\n在write系统调用的最后（也就是事务结束时），这些更新都被从 block cache 拷贝到了 log 中，之后会更新 header block 的计数来表明当前的 transaction 已经结束了。\n\n\n\n更新 header block 的计数这个操作是一个原子操作（得益于硬件支持），被称为 commit point。如果系统在 commit point 之前崩溃，则相当于事务在执行时中断，我们便放弃之前已有的全部更改。但如果系统在 commit point 之后崩溃，则相当于事务已经执行完毕（但是还没有回收）。虽然此时 log 中的变更还没有写入到磁盘对应的位置，但是即使在此时崩溃重启时也可以根据 log 中的记录恢复之前的更改。\n\n\n\ncommit point 之后当然是将 log 中的变更写回磁盘，然后清除 header block 中的计数（计数清除被视作释放了一个事务），至此一个事务的流程完成。\n\n\n### **ext3**\n\n\next3 是在真实世界中使用的一种文件系统实现，直到现在也仍然经常在 linux 上使用。我们可以轻易的在 linux 上以 ext3 文件系统的格式挂载一块硬盘：\n\n\n```bash\nsudo vim /etc/fstab # 在文件末尾加上 /dev/<设备> <要挂载的路径> ext3 defaults 1 1\n```\n\n\next3 的实现思路是基于 [Journaling the Linux ext2fs Filesystem](https://pdos.csail.mit.edu/6.828/2020/readings/journal-design.pdf) 中描述的一种高性能高可靠文件系统实现。其实现方式跟 xv6 的文件系统实现有很多类似的地方，不过因为其用于现实世界，所以比 xv6 考虑了更多细节，且总体上性能要更好（好得多）：\n\n\n- ext3 提供了异步系统调用 ，即系统修改完 block cache 就直接返回（是的，ext3 上的 write 系统调用返回时数据其实还没有被写到磁盘上，在这个中途 crash 事务是有可能回滚的）\n\n- ext3 支持批处理 (batching) ，即 ext3 可以合并一段时间内的所有事务，最后将其作为一个大事务进行提交，这样做整体只会向磁盘中写入一次数据。\n\t- 首先批处理减少了事务带来的开销，从机械硬盘中查找log的位置实际上开销不小，而批处理合并了多个事务，减少了事务执行的次数。\n\t\t- 如果之前的多个事务中都修改了同一个block，批处理后写入磁盘时就只需要写入一次 (这种情况被称作 write absorbing)，相当于减少了磁盘 io。\n\t\t- 批处理利好 disk scheduling\n\t\t- 磁盘的读写也是具有局部性的，一次性的向磁盘的连续位置写入1000个block，要比分1000次每次写一个不同位置的磁盘block快得多。写log就是向磁盘的连续位置写block。通过向磁盘提交大批量的写操作，可以更加的高效。\n\t\t\t- 如果能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新block的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得disk scheduling。这是batching带来的另一个好处。\n\t\t\n- 良好的并发性能 concurrency\n\t- ext3 允许并行写操作，在一个总的事务提交之前，其他 write 系统调用不必等待到当前事务执行完毕，而是直接让 write 操作合并到当前事务当中。\n\t\t- 可以有不同的 transaction 同时存在，尽管只有一个 open transaction 可以接收系统调用。\n\t\t- 一个 open transaction\n\t\t\t- 若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的open transaction中进行。\n\t\t\t- 若干个正在从cache中向文件系统block写数据的transaction\n\t\t\t- 若干个正在被释放的transaction，这个并不占用太多的工作\n\t\t\t- 也就是说 提交事务 ，写入磁盘，释放事务 这三个操作都是异步的。\n\t\t\n\n\n\n","slug":"xv6-fs","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ullc0005fbsbb11gdjvx","content":"<blockquote>\n<p>下文中没有具体说明的场景均描述 xv6 文件系统的实现</p>\n</blockquote>\n<p>好吧 我们就来详细捋一捋 fs</p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a><strong>组成</strong></h2><p>&#x2F;&#x2F; todo</p>\n<h2 id=\"事务-Transaction\"><a href=\"#事务-Transaction\" class=\"headerlink\" title=\"事务 Transaction\"></a><strong>事务 Transaction</strong></h2><blockquote>\n<p>事务在用数据库的时候就已经经常用到了，但是没想到文件系统也有事务。从文件系统的事务实现中我们也可以管中窥豹数据库的事务是怎么实现的，数据库的 crash recovery 是如何保证的。</p>\n</blockquote>\n<h3 id=\"xv6\"><a href=\"#xv6\" class=\"headerlink\" title=\"xv6\"></a><strong>xv6</strong></h3><p>事务的作用是保证一组磁盘写操作的原子性 （即要么全部完成，要么全部失败)，从而支持 crash recovery。事务是我们对一组整体具有原子性的磁盘写操作的抽象，而我们是如何实现事务这个特性的呢？</p>\n<p>当然是凭借日志系统。在xv6中，我们在执行一组磁盘写操作时，会先将这组写操作发到 block cache。block cache 就是磁盘 block 在内存中的 copy。</p>\n<p>在write系统调用的最后（也就是事务结束时），这些更新都被从 block cache 拷贝到了 log 中，之后会更新 header block 的计数来表明当前的 transaction 已经结束了。</p>\n<p>更新 header block 的计数这个操作是一个原子操作（得益于硬件支持），被称为 commit point。如果系统在 commit point 之前崩溃，则相当于事务在执行时中断，我们便放弃之前已有的全部更改。但如果系统在 commit point 之后崩溃，则相当于事务已经执行完毕（但是还没有回收）。虽然此时 log 中的变更还没有写入到磁盘对应的位置，但是即使在此时崩溃重启时也可以根据 log 中的记录恢复之前的更改。</p>\n<p>commit point 之后当然是将 log 中的变更写回磁盘，然后清除 header block 中的计数（计数清除被视作释放了一个事务），至此一个事务的流程完成。</p>\n<h3 id=\"ext3\"><a href=\"#ext3\" class=\"headerlink\" title=\"ext3\"></a><strong>ext3</strong></h3><p>ext3 是在真实世界中使用的一种文件系统实现，直到现在也仍然经常在 linux 上使用。我们可以轻易的在 linux 上以 ext3 文件系统的格式挂载一块硬盘：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/fstab <span class=\"comment\"># 在文件末尾加上 /dev/&lt;设备&gt; &lt;要挂载的路径&gt; ext3 defaults 1 1</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ext3 的实现思路是基于 <a href=\"https://pdos.csail.mit.edu/6.828/2020/readings/journal-design.pdf\">Journaling the Linux ext2fs Filesystem</a> 中描述的一种高性能高可靠文件系统实现。其实现方式跟 xv6 的文件系统实现有很多类似的地方，不过因为其用于现实世界，所以比 xv6 考虑了更多细节，且总体上性能要更好（好得多）：</p>\n<ul>\n<li><p>ext3 提供了异步系统调用 ，即系统修改完 block cache 就直接返回（是的，ext3 上的 write 系统调用返回时数据其实还没有被写到磁盘上，在这个中途 crash 事务是有可能回滚的）</p>\n</li>\n<li><p>ext3 支持批处理 (batching) ，即 ext3 可以合并一段时间内的所有事务，最后将其作为一个大事务进行提交，这样做整体只会向磁盘中写入一次数据。</p>\n<ul>\n<li>首先批处理减少了事务带来的开销，从机械硬盘中查找log的位置实际上开销不小，而批处理合并了多个事务，减少了事务执行的次数。<ul>\n<li>如果之前的多个事务中都修改了同一个block，批处理后写入磁盘时就只需要写入一次 (这种情况被称作 write absorbing)，相当于减少了磁盘 io。</li>\n<li>批处理利好 disk scheduling</li>\n<li>磁盘的读写也是具有局部性的，一次性的向磁盘的连续位置写入1000个block，要比分1000次每次写一个不同位置的磁盘block快得多。写log就是向磁盘的连续位置写block。通过向磁盘提交大批量的写操作，可以更加的高效。<ul>\n<li>如果能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新block的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得disk scheduling。这是batching带来的另一个好处。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>良好的并发性能 concurrency</p>\n<ul>\n<li>ext3 允许并行写操作，在一个总的事务提交之前，其他 write 系统调用不必等待到当前事务执行完毕，而是直接让 write 操作合并到当前事务当中。<ul>\n<li>可以有不同的 transaction 同时存在，尽管只有一个 open transaction 可以接收系统调用。</li>\n<li>一个 open transaction<ul>\n<li>若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的open transaction中进行。</li>\n<li>若干个正在从cache中向文件系统block写数据的transaction</li>\n<li>若干个正在被释放的transaction，这个并不占用太多的工作</li>\n<li>也就是说 提交事务 ，写入磁盘，释放事务 这三个操作都是异步的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>下文中没有具体说明的场景均描述 xv6 文件系统的实现</p>\n</blockquote>\n<p>好吧 我们就来详细捋一捋 fs</p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a><strong>组成</strong></h2><p>&#x2F;&#x2F; todo</p>\n<h2 id=\"事务-Transaction\"><a href=\"#事务-Transaction\" class=\"headerlink\" title=\"事务 Transaction\"></a><strong>事务 Transaction</strong></h2><blockquote>\n<p>事务在用数据库的时候就已经经常用到了，但是没想到文件系统也有事务。从文件系统的事务实现中我们也可以管中窥豹数据库的事务是怎么实现的，数据库的 crash recovery 是如何保证的。</p>\n</blockquote>\n<h3 id=\"xv6\"><a href=\"#xv6\" class=\"headerlink\" title=\"xv6\"></a><strong>xv6</strong></h3><p>事务的作用是保证一组磁盘写操作的原子性 （即要么全部完成，要么全部失败)，从而支持 crash recovery。事务是我们对一组整体具有原子性的磁盘写操作的抽象，而我们是如何实现事务这个特性的呢？</p>\n<p>当然是凭借日志系统。在xv6中，我们在执行一组磁盘写操作时，会先将这组写操作发到 block cache。block cache 就是磁盘 block 在内存中的 copy。</p>\n<p>在write系统调用的最后（也就是事务结束时），这些更新都被从 block cache 拷贝到了 log 中，之后会更新 header block 的计数来表明当前的 transaction 已经结束了。</p>\n<p>更新 header block 的计数这个操作是一个原子操作（得益于硬件支持），被称为 commit point。如果系统在 commit point 之前崩溃，则相当于事务在执行时中断，我们便放弃之前已有的全部更改。但如果系统在 commit point 之后崩溃，则相当于事务已经执行完毕（但是还没有回收）。虽然此时 log 中的变更还没有写入到磁盘对应的位置，但是即使在此时崩溃重启时也可以根据 log 中的记录恢复之前的更改。</p>\n<p>commit point 之后当然是将 log 中的变更写回磁盘，然后清除 header block 中的计数（计数清除被视作释放了一个事务），至此一个事务的流程完成。</p>\n<h3 id=\"ext3\"><a href=\"#ext3\" class=\"headerlink\" title=\"ext3\"></a><strong>ext3</strong></h3><p>ext3 是在真实世界中使用的一种文件系统实现，直到现在也仍然经常在 linux 上使用。我们可以轻易的在 linux 上以 ext3 文件系统的格式挂载一块硬盘：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/fstab <span class=\"comment\"># 在文件末尾加上 /dev/&lt;设备&gt; &lt;要挂载的路径&gt; ext3 defaults 1 1</span></span><br></pre></td></tr></table></figure>\n\n\n<p>ext3 的实现思路是基于 <a href=\"https://pdos.csail.mit.edu/6.828/2020/readings/journal-design.pdf\">Journaling the Linux ext2fs Filesystem</a> 中描述的一种高性能高可靠文件系统实现。其实现方式跟 xv6 的文件系统实现有很多类似的地方，不过因为其用于现实世界，所以比 xv6 考虑了更多细节，且总体上性能要更好（好得多）：</p>\n<ul>\n<li><p>ext3 提供了异步系统调用 ，即系统修改完 block cache 就直接返回（是的，ext3 上的 write 系统调用返回时数据其实还没有被写到磁盘上，在这个中途 crash 事务是有可能回滚的）</p>\n</li>\n<li><p>ext3 支持批处理 (batching) ，即 ext3 可以合并一段时间内的所有事务，最后将其作为一个大事务进行提交，这样做整体只会向磁盘中写入一次数据。</p>\n<ul>\n<li>首先批处理减少了事务带来的开销，从机械硬盘中查找log的位置实际上开销不小，而批处理合并了多个事务，减少了事务执行的次数。<ul>\n<li>如果之前的多个事务中都修改了同一个block，批处理后写入磁盘时就只需要写入一次 (这种情况被称作 write absorbing)，相当于减少了磁盘 io。</li>\n<li>批处理利好 disk scheduling</li>\n<li>磁盘的读写也是具有局部性的，一次性的向磁盘的连续位置写入1000个block，要比分1000次每次写一个不同位置的磁盘block快得多。写log就是向磁盘的连续位置写block。通过向磁盘提交大批量的写操作，可以更加的高效。<ul>\n<li>如果能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，这也很有效。在一个机械硬盘上，如果一次发送大量需要更新block的写请求，驱动可以对这些写请求根据轨道号排序。甚至在一个固态硬盘中，通过一次发送给硬盘大量的更新操作也可以稍微提升性能。所以，只有发送给驱动大量的写操作，才有可能获得disk scheduling。这是batching带来的另一个好处。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>良好的并发性能 concurrency</p>\n<ul>\n<li>ext3 允许并行写操作，在一个总的事务提交之前，其他 write 系统调用不必等待到当前事务执行完毕，而是直接让 write 操作合并到当前事务当中。<ul>\n<li>可以有不同的 transaction 同时存在，尽管只有一个 open transaction 可以接收系统调用。</li>\n<li>一个 open transaction<ul>\n<li>若干个正在commit到log的transaction，我们并不需要等待这些transaction结束。当之前的transaction还没有commit并还在写log的过程中，新的系统调用仍然可以在当前的open transaction中进行。</li>\n<li>若干个正在从cache中向文件系统block写数据的transaction</li>\n<li>若干个正在被释放的transaction，这个并不占用太多的工作</li>\n<li>也就是说 提交事务 ，写入磁盘，释放事务 这三个操作都是异步的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"周报","urlname":"FashdhbmXovCtwxNwgHckhrunRt","date":"2023-12-25T04:25:01.000Z","updated":"2024-01-18T09:31:25.000Z","_content":"# 2023.12.18~12.24\n\n\n因为游戏账号被封了一个月所以开始写周报 push 自己学习的第一周（\n\n\n\n看到学弟在学 6.824，说实话有点慌，真得 push 一下自己了\n\n\n### **学习 & 工作**\n\n- 完成 CS106B 的 assignment 1，2\n\n\n- 目前为止都是一些很简单的内容，还没有涉及到我比较想学的部分\n\n\n- 参加了\n\n\n\n  Datenlord 的 mit 体系结构公开课学习社区\n\n\n- 学习的课程是 6.004 6.175 6.375 ，这三门课的知识点重复度很高，大概只需要看 6.004 的课，做 6.175 的 lab，穿插学习 6.375 即可\n\n- 不过大概率不会坚持到最后，只是一个学习计组的契机\n\n- 学习体系结构的过程中也会并发进行另一门公开课的学习，目前是 CS106X，之后会做 445 和 824\n\n\n### **生活**\n\n- 久违的下了个音游（邦邦）来玩，发现了一首[很不错的曲子](https://open.spotify.com/track/0bmJzYti6K65ytyLH6VTMR?si=809fadc6c8b04a47)\n\n\n## **下周计划**\n\n\n下周其实离考试周就很近了，所以不一定能做完\n\n\n- 过完 6.004 讲 bluespec 之前的内容\n\n- 过完一半 CS106X 的课，至少再完成 CS106B 的两个 lab\n\n","source":"_posts/周报.md","raw":"---\ntitle: 周报\nurlname: FashdhbmXovCtwxNwgHckhrunRt\ndate: 2023-12-25T12:25:01.000Z\nupdated: '2024-01-18 17:31:25'\ntags:\n  - 周报\n---\n# 2023.12.18~12.24\n\n\n因为游戏账号被封了一个月所以开始写周报 push 自己学习的第一周（\n\n\n\n看到学弟在学 6.824，说实话有点慌，真得 push 一下自己了\n\n\n### **学习 & 工作**\n\n- 完成 CS106B 的 assignment 1，2\n\n\n- 目前为止都是一些很简单的内容，还没有涉及到我比较想学的部分\n\n\n- 参加了\n\n\n\n  Datenlord 的 mit 体系结构公开课学习社区\n\n\n- 学习的课程是 6.004 6.175 6.375 ，这三门课的知识点重复度很高，大概只需要看 6.004 的课，做 6.175 的 lab，穿插学习 6.375 即可\n\n- 不过大概率不会坚持到最后，只是一个学习计组的契机\n\n- 学习体系结构的过程中也会并发进行另一门公开课的学习，目前是 CS106X，之后会做 445 和 824\n\n\n### **生活**\n\n- 久违的下了个音游（邦邦）来玩，发现了一首[很不错的曲子](https://open.spotify.com/track/0bmJzYti6K65ytyLH6VTMR?si=809fadc6c8b04a47)\n\n\n## **下周计划**\n\n\n下周其实离考试周就很近了，所以不一定能做完\n\n\n- 过完 6.004 讲 bluespec 之前的内容\n\n- 过完一半 CS106X 的课，至少再完成 CS106B 的两个 lab\n\n","slug":"周报","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ulld0009fbsb1kcm8m42","content":"<h1 id=\"2023-12-18-12-24\"><a href=\"#2023-12-18-12-24\" class=\"headerlink\" title=\"2023.12.18~12.24\"></a>2023.12.18~12.24</h1><p>因为游戏账号被封了一个月所以开始写周报 push 自己学习的第一周（</p>\n<p>看到学弟在学 6.824，说实话有点慌，真得 push 一下自己了</p>\n<h3 id=\"学习-amp-工作\"><a href=\"#学习-amp-工作\" class=\"headerlink\" title=\"学习 &amp; 工作\"></a><strong>学习 &amp; 工作</strong></h3><ul>\n<li><p>完成 CS106B 的 assignment 1，2</p>\n</li>\n<li><p>目前为止都是一些很简单的内容，还没有涉及到我比较想学的部分</p>\n</li>\n<li><p>参加了</p>\n<p>Datenlord 的 mit 体系结构公开课学习社区</p>\n</li>\n<li><p>学习的课程是 6.004 6.175 6.375 ，这三门课的知识点重复度很高，大概只需要看 6.004 的课，做 6.175 的 lab，穿插学习 6.375 即可</p>\n</li>\n<li><p>不过大概率不会坚持到最后，只是一个学习计组的契机</p>\n</li>\n<li><p>学习体系结构的过程中也会并发进行另一门公开课的学习，目前是 CS106X，之后会做 445 和 824</p>\n</li>\n</ul>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a><strong>生活</strong></h3><ul>\n<li>久违的下了个音游（邦邦）来玩，发现了一首<a href=\"https://open.spotify.com/track/0bmJzYti6K65ytyLH6VTMR?si=809fadc6c8b04a47\">很不错的曲子</a></li>\n</ul>\n<h2 id=\"下周计划\"><a href=\"#下周计划\" class=\"headerlink\" title=\"下周计划\"></a><strong>下周计划</strong></h2><p>下周其实离考试周就很近了，所以不一定能做完</p>\n<ul>\n<li><p>过完 6.004 讲 bluespec 之前的内容</p>\n</li>\n<li><p>过完一半 CS106X 的课，至少再完成 CS106B 的两个 lab</p>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<h1 id=\"2023-12-18-12-24\"><a href=\"#2023-12-18-12-24\" class=\"headerlink\" title=\"2023.12.18~12.24\"></a>2023.12.18~12.24</h1><p>因为游戏账号被封了一个月所以开始写周报 push 自己学习的第一周（</p>\n<p>看到学弟在学 6.824，说实话有点慌，真得 push 一下自己了</p>\n<h3 id=\"学习-amp-工作\"><a href=\"#学习-amp-工作\" class=\"headerlink\" title=\"学习 &amp; 工作\"></a><strong>学习 &amp; 工作</strong></h3><ul>\n<li><p>完成 CS106B 的 assignment 1，2</p>\n</li>\n<li><p>目前为止都是一些很简单的内容，还没有涉及到我比较想学的部分</p>\n</li>\n<li><p>参加了</p>\n<p>Datenlord 的 mit 体系结构公开课学习社区</p>\n</li>\n<li><p>学习的课程是 6.004 6.175 6.375 ，这三门课的知识点重复度很高，大概只需要看 6.004 的课，做 6.175 的 lab，穿插学习 6.375 即可</p>\n</li>\n<li><p>不过大概率不会坚持到最后，只是一个学习计组的契机</p>\n</li>\n<li><p>学习体系结构的过程中也会并发进行另一门公开课的学习，目前是 CS106X，之后会做 445 和 824</p>\n</li>\n</ul>\n<h3 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a><strong>生活</strong></h3><ul>\n<li>久违的下了个音游（邦邦）来玩，发现了一首<a href=\"https://open.spotify.com/track/0bmJzYti6K65ytyLH6VTMR?si=809fadc6c8b04a47\">很不错的曲子</a></li>\n</ul>\n<h2 id=\"下周计划\"><a href=\"#下周计划\" class=\"headerlink\" title=\"下周计划\"></a><strong>下周计划</strong></h2><p>下周其实离考试周就很近了，所以不一定能做完</p>\n<ul>\n<li><p>过完 6.004 讲 bluespec 之前的内容</p>\n</li>\n<li><p>过完一半 CS106X 的课，至少再完成 CS106B 的两个 lab</p>\n</li>\n</ul>\n"},{"title":"新的开始","urlname":"VKtzd4IhRo6MwPxfJuDcow4gnwb","date":"2023-06-27T16:01:19.000Z","updated":"2024-01-18T09:11:43.000Z","_content":"看了一下周围人的博客，觉得我原来的博客实在是花里胡哨且没有营养，于是删掉以前的所有文章，顺便换了个清爽的主题：butterfly，并且给博客支持了 RSS 订阅。\n\n泡泡曾推荐我使用他的方案 `zola + no-style-please`。不过我实在懒得折腾 `zola`，并且 `no-style-please` 对我来说有些过于简约了。\n\n总之以后我会尽我所能的产出高质量博客，而不是像以前一样鸡毛蒜皮的小事也要水一篇博文 :D\n\n\n\n> 简约并不是简陋，简约的目的是抽出设计中最核心的部分。这和编程一样，抽象出主要部分的程序总是很好理解且很好维护的，而不是追究任何一个细小的结构，为其套上各种设计模式，最终的结果只会是难以维护，和当初运用各种设计模式的初衷背离了。\n\n\n","source":"_posts/新的开始.md","raw":"---\ntitle: 新的开始\nurlname: VKtzd4IhRo6MwPxfJuDcow4gnwb\ndate: 2023-06-28T00:01:19.000Z\nupdated: '2024-01-18 17:11:43'\ntags: 闲聊\n---\n看了一下周围人的博客，觉得我原来的博客实在是花里胡哨且没有营养，于是删掉以前的所有文章，顺便换了个清爽的主题：butterfly，并且给博客支持了 RSS 订阅。\n\n泡泡曾推荐我使用他的方案 `zola + no-style-please`。不过我实在懒得折腾 `zola`，并且 `no-style-please` 对我来说有些过于简约了。\n\n总之以后我会尽我所能的产出高质量博客，而不是像以前一样鸡毛蒜皮的小事也要水一篇博文 :D\n\n\n\n> 简约并不是简陋，简约的目的是抽出设计中最核心的部分。这和编程一样，抽象出主要部分的程序总是很好理解且很好维护的，而不是追究任何一个细小的结构，为其套上各种设计模式，最终的结果只会是难以维护，和当初运用各种设计模式的初衷背离了。\n\n\n","slug":"新的开始","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ulld000afbsb47kx9h7w","content":"<p>看了一下周围人的博客，觉得我原来的博客实在是花里胡哨且没有营养，于是删掉以前的所有文章，顺便换了个清爽的主题：butterfly，并且给博客支持了 RSS 订阅。</p>\n<p>泡泡曾推荐我使用他的方案 <code>zola + no-style-please</code>。不过我实在懒得折腾 <code>zola</code>，并且 <code>no-style-please</code> 对我来说有些过于简约了。</p>\n<p>总之以后我会尽我所能的产出高质量博客，而不是像以前一样鸡毛蒜皮的小事也要水一篇博文 :D</p>\n<blockquote>\n<p>简约并不是简陋，简约的目的是抽出设计中最核心的部分。这和编程一样，抽象出主要部分的程序总是很好理解且很好维护的，而不是追究任何一个细小的结构，为其套上各种设计模式，最终的结果只会是难以维护，和当初运用各种设计模式的初衷背离了。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<p>看了一下周围人的博客，觉得我原来的博客实在是花里胡哨且没有营养，于是删掉以前的所有文章，顺便换了个清爽的主题：butterfly，并且给博客支持了 RSS 订阅。</p>\n<p>泡泡曾推荐我使用他的方案 <code>zola + no-style-please</code>。不过我实在懒得折腾 <code>zola</code>，并且 <code>no-style-please</code> 对我来说有些过于简约了。</p>\n<p>总之以后我会尽我所能的产出高质量博客，而不是像以前一样鸡毛蒜皮的小事也要水一篇博文 :D</p>\n<blockquote>\n<p>简约并不是简陋，简约的目的是抽出设计中最核心的部分。这和编程一样，抽象出主要部分的程序总是很好理解且很好维护的，而不是追究任何一个细小的结构，为其套上各种设计模式，最终的结果只会是难以维护，和当初运用各种设计模式的初衷背离了。</p>\n</blockquote>\n"},{"title":"博客写作部署分离实践","urlname":"GcC9d15VKoMKpixcYB5cPntunsf","date":"2024-01-18T08:10:27.000Z","updated":"2024-01-18T09:11:56.000Z","_content":"使用了 [Elog](https://elog.1874.cool) 一键同步飞书文档上编写的博客文章到 hexo 仓库，以后博文迁移到飞书文档上编写。\n\n发现这玩意好像也不是很好用，感觉可以自己写一个。不过感觉有点浪费时间，算了。\n\n> 该博文同步自飞书文档\n\n\n","source":"_posts/博客写作部署分离实践.md","raw":"---\ntitle: 博客写作部署分离实践\nurlname: GcC9d15VKoMKpixcYB5cPntunsf\ndate: 2024-01-18T16:10:27.000Z\nupdated: '2024-01-18 17:11:56'\ntags:\n  - 随笔\n---\n使用了 [Elog](https://elog.1874.cool) 一键同步飞书文档上编写的博客文章到 hexo 仓库，以后博文迁移到飞书文档上编写。\n\n发现这玩意好像也不是很好用，感觉可以自己写一个。不过感觉有点浪费时间，算了。\n\n> 该博文同步自飞书文档\n\n\n","slug":"博客写作部署分离实践","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ulle000cfbsbeun5328q","content":"<p>使用了 <a href=\"https://elog.1874.cool/\">Elog</a> 一键同步飞书文档上编写的博客文章到 hexo 仓库，以后博文迁移到飞书文档上编写。</p>\n<p>发现这玩意好像也不是很好用，感觉可以自己写一个。不过感觉有点浪费时间，算了。</p>\n<blockquote>\n<p>该博文同步自飞书文档</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<p>使用了 <a href=\"https://elog.1874.cool/\">Elog</a> 一键同步飞书文档上编写的博客文章到 hexo 仓库，以后博文迁移到飞书文档上编写。</p>\n<p>发现这玩意好像也不是很好用，感觉可以自己写一个。不过感觉有点浪费时间，算了。</p>\n<blockquote>\n<p>该博文同步自飞书文档</p>\n</blockquote>\n"},{"title":"解决 bear 在 MacOS 中生成空 compile_commands.json","urlname":"URYldeyG7okwIlxnz6lcVpvHnqE","date":"2023-10-21T09:50:29.000Z","updated":"2024-01-18T09:11:09.000Z","_content":"在做到 xv6 的最后一个 lab 时，我终于忍受不了满屏的爆红，着手开始配置代码高亮。参考  https://zhuanlan.zhihu.com/p/501901665 配置 Intellisense，然后我遇到了一个问题：\n\n\n\n> make clean && bear — make qemu 生成空 compile_commands.json\n\n\n\n我 google 查了一下，目前没有中文博客提到这个问题。我在 Bear 的 issue 下发现这个问题已经老生常谈了，因为 linux 和 macos 下 bear 的工作原理不同：\n\n\n\n> For your problem, here is a little background information... Bear works differently on Linux and Mac. On Linux it intercept the process executions with a preloaded shared object. This trick does not work on Mac. Instead it use compiler wrapper, which reports the process executions... The compiler wrapper interposing only works with builds, which are open to override the compiler.\n\n\n\n所以其实在 mac 上，bear 预先准备了一系列常用编译器的wrapper。\n\n\n\n![1](https://persecution-1301196908.cos.ap-chongqing.myqcloud.com/image_bed1.png)\n\n\n\n因为 xv6 使用的编译器是 `riscv-unknown-elf-gcc` , 没有预置它的 wrapper。所以我们需要手动创建它：\n\n\n```bash\nln -s /opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper \\\\\n/opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper.d/riscv-unknown-elf-gcc\n```\n\n\n然后 bear 就可以正常工作了:D\n","source":"_posts/解决 bear 在 MacOS 中生成空 compile_commands.json.md","raw":"---\ntitle: 解决 bear 在 MacOS 中生成空 compile_commands.json\nurlname: URYldeyG7okwIlxnz6lcVpvHnqE\ndate: 2023-10-21T17:50:29.000Z\nupdated: '2024-01-18 17:11:09'\ntags:\n  - xv6\n  - 编译\n---\n在做到 xv6 的最后一个 lab 时，我终于忍受不了满屏的爆红，着手开始配置代码高亮。参考  https://zhuanlan.zhihu.com/p/501901665 配置 Intellisense，然后我遇到了一个问题：\n\n\n\n> make clean && bear — make qemu 生成空 compile_commands.json\n\n\n\n我 google 查了一下，目前没有中文博客提到这个问题。我在 Bear 的 issue 下发现这个问题已经老生常谈了，因为 linux 和 macos 下 bear 的工作原理不同：\n\n\n\n> For your problem, here is a little background information... Bear works differently on Linux and Mac. On Linux it intercept the process executions with a preloaded shared object. This trick does not work on Mac. Instead it use compiler wrapper, which reports the process executions... The compiler wrapper interposing only works with builds, which are open to override the compiler.\n\n\n\n所以其实在 mac 上，bear 预先准备了一系列常用编译器的wrapper。\n\n\n\n![1](https://persecution-1301196908.cos.ap-chongqing.myqcloud.com/image_bed1.png)\n\n\n\n因为 xv6 使用的编译器是 `riscv-unknown-elf-gcc` , 没有预置它的 wrapper。所以我们需要手动创建它：\n\n\n```bash\nln -s /opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper \\\\\n/opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper.d/riscv-unknown-elf-gcc\n```\n\n\n然后 bear 就可以正常工作了:D\n","slug":"解决 bear 在 MacOS 中生成空 compile_commands.json","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clrj0ullf000efbsbbzia69rz","content":"<p>在做到 xv6 的最后一个 lab 时，我终于忍受不了满屏的爆红，着手开始配置代码高亮。参考  <a href=\"https://zhuanlan.zhihu.com/p/501901665\">https://zhuanlan.zhihu.com/p/501901665</a> 配置 Intellisense，然后我遇到了一个问题：</p>\n<blockquote>\n<p>make clean &amp;&amp; bear — make qemu 生成空 compile_commands.json</p>\n</blockquote>\n<p>我 google 查了一下，目前没有中文博客提到这个问题。我在 Bear 的 issue 下发现这个问题已经老生常谈了，因为 linux 和 macos 下 bear 的工作原理不同：</p>\n<blockquote>\n<p>For your problem, here is a little background information… Bear works differently on Linux and Mac. On Linux it intercept the process executions with a preloaded shared object. This trick does not work on Mac. Instead it use compiler wrapper, which reports the process executions… The compiler wrapper interposing only works with builds, which are open to override the compiler.</p>\n</blockquote>\n<p>所以其实在 mac 上，bear 预先准备了一系列常用编译器的wrapper。</p>\n<p><img src=\"https://persecution-1301196908.cos.ap-chongqing.myqcloud.com/image_bed1.png\" alt=\"1\"></p>\n<p>因为 xv6 使用的编译器是 <code>riscv-unknown-elf-gcc</code> , 没有预置它的 wrapper。所以我们需要手动创建它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ln</span> -s /opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper \\\\</span><br><span class=\"line\">/opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper.d/riscv-unknown-elf-gcc</span><br></pre></td></tr></table></figure>\n\n\n<p>然后 bear 就可以正常工作了:D</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"寒雨的朋友们","link_list":[{"name":"泡泡","link":"https://blog.skygard.cn/","avatar":"https://avatars.githubusercontent.com/u/59405399?v=4","descr":"Keep Learning..."},{"name":"StellarisW","link":"https://blog.stellaris.wang/","avatar":"https://avatars.githubusercontent.com/u/46246823?v=4","descr":"Keep Learning..."},{"name":"闲蛋","link":"https://kirraobj.ink/","avatar":"https://avatars.githubusercontent.com/u/36192515?v=4","descr":"pl enthusiast | fp fanboy | 追随背影。"}]}]}},"cover":false,"excerpt":"","more":"<p>在做到 xv6 的最后一个 lab 时，我终于忍受不了满屏的爆红，着手开始配置代码高亮。参考  <a href=\"https://zhuanlan.zhihu.com/p/501901665\">https://zhuanlan.zhihu.com/p/501901665</a> 配置 Intellisense，然后我遇到了一个问题：</p>\n<blockquote>\n<p>make clean &amp;&amp; bear — make qemu 生成空 compile_commands.json</p>\n</blockquote>\n<p>我 google 查了一下，目前没有中文博客提到这个问题。我在 Bear 的 issue 下发现这个问题已经老生常谈了，因为 linux 和 macos 下 bear 的工作原理不同：</p>\n<blockquote>\n<p>For your problem, here is a little background information… Bear works differently on Linux and Mac. On Linux it intercept the process executions with a preloaded shared object. This trick does not work on Mac. Instead it use compiler wrapper, which reports the process executions… The compiler wrapper interposing only works with builds, which are open to override the compiler.</p>\n</blockquote>\n<p>所以其实在 mac 上，bear 预先准备了一系列常用编译器的wrapper。</p>\n<p><img src=\"https://persecution-1301196908.cos.ap-chongqing.myqcloud.com/image_bed1.png\" alt=\"1\"></p>\n<p>因为 xv6 使用的编译器是 <code>riscv-unknown-elf-gcc</code> , 没有预置它的 wrapper。所以我们需要手动创建它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ln</span> -s /opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper \\\\</span><br><span class=\"line\">/opt/homebrew/Cellar/bear/3.1.3_7/lib/bear/wrapper.d/riscv-unknown-elf-gcc</span><br></pre></td></tr></table></figure>\n\n\n<p>然后 bear 就可以正常工作了:D</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clrj0ullc0004fbsbb7ag7wil","category_id":"clrj0ulld0007fbsbdles120h","_id":"clrj0ullf000hfbsbfdmh10uy"},{"post_id":"clrj0ullc0005fbsbb11gdjvx","category_id":"clrj0ulld0007fbsbdles120h","_id":"clrj0ullf000lfbsb626the70"}],"PostTag":[{"post_id":"clrj0ull70000fbsb46r10n7p","tag_id":"clrj0ullb0002fbsb8s0w4qt1","_id":"clrj0ulld0008fbsb5jdv14si"},{"post_id":"clrj0ulle000cfbsbeun5328q","tag_id":"clrj0ulle000bfbsb1sic56rw","_id":"clrj0ullf000gfbsbfgbg5ycd"},{"post_id":"clrj0ulla0001fbsbhpfb0n7c","tag_id":"clrj0ulld0006fbsbhlk77axj","_id":"clrj0ullf000ifbsbfht79eni"},{"post_id":"clrj0ulla0001fbsbhpfb0n7c","tag_id":"clrj0ulle000bfbsb1sic56rw","_id":"clrj0ullf000jfbsb6ovsaim8"},{"post_id":"clrj0ullb0003fbsb0ona3ahw","tag_id":"clrj0ullf000ffbsbb29f3pgw","_id":"clrj0ullf000nfbsb4mkt7xtz"},{"post_id":"clrj0ullb0003fbsb0ona3ahw","tag_id":"clrj0ullf000kfbsbccztbyr9","_id":"clrj0ullf000ofbsbfoof4swc"},{"post_id":"clrj0ullc0004fbsbb7ag7wil","tag_id":"clrj0ullf000mfbsb5dbzd04p","_id":"clrj0ullg000ufbsbcj1af0vz"},{"post_id":"clrj0ullc0004fbsbb7ag7wil","tag_id":"clrj0ullf000pfbsb5xkr9z8a","_id":"clrj0ullg000vfbsb3hrmfply"},{"post_id":"clrj0ullc0004fbsbb7ag7wil","tag_id":"clrj0ullg000qfbsb9ki56hdl","_id":"clrj0ullg000xfbsbfbuj86bp"},{"post_id":"clrj0ullc0004fbsbb7ag7wil","tag_id":"clrj0ullg000rfbsbh772evkk","_id":"clrj0ullg000yfbsb01bo8g9p"},{"post_id":"clrj0ullc0004fbsbb7ag7wil","tag_id":"clrj0ullg000sfbsb1fnzf783","_id":"clrj0ullg0010fbsbfjuu09d3"},{"post_id":"clrj0ullc0005fbsbb11gdjvx","tag_id":"clrj0ullf000pfbsb5xkr9z8a","_id":"clrj0ullg0013fbsb2stlaov7"},{"post_id":"clrj0ullc0005fbsbb11gdjvx","tag_id":"clrj0ullg000qfbsb9ki56hdl","_id":"clrj0ullg0014fbsbcfzjfa2l"},{"post_id":"clrj0ullc0005fbsbb11gdjvx","tag_id":"clrj0ullg000zfbsb8677fj4e","_id":"clrj0ullg0016fbsbctixefmz"},{"post_id":"clrj0ullc0005fbsbb11gdjvx","tag_id":"clrj0ullf000mfbsb5dbzd04p","_id":"clrj0ullg0017fbsbg24m9hu8"},{"post_id":"clrj0ulld0009fbsb1kcm8m42","tag_id":"clrj0ullg0012fbsb36ck1548","_id":"clrj0ullg0019fbsb4i872xxi"},{"post_id":"clrj0ulld000afbsb47kx9h7w","tag_id":"clrj0ullg0015fbsb2p7m9m5w","_id":"clrj0ullg001afbsbakdpgq5t"},{"post_id":"clrj0ullf000efbsbbzia69rz","tag_id":"clrj0ullf000mfbsb5dbzd04p","_id":"clrj0ullg001cfbsb8cwbg4w9"},{"post_id":"clrj0ullf000efbsbbzia69rz","tag_id":"clrj0ullg001bfbsb0iz5h6py","_id":"clrj0ullg001dfbsb4u4zh5an"}],"Tag":[{"name":"总结","_id":"clrj0ullb0002fbsb8s0w4qt1"},{"name":"年度总结","_id":"clrj0ulld0006fbsbhlk77axj"},{"name":"随笔","_id":"clrj0ulle000bfbsb1sic56rw"},{"name":"android","_id":"clrj0ullf000ffbsbb29f3pgw"},{"name":"八股","_id":"clrj0ullf000kfbsbccztbyr9"},{"name":"xv6","_id":"clrj0ullf000mfbsb5dbzd04p"},{"name":"公开课","_id":"clrj0ullf000pfbsb5xkr9z8a"},{"name":"MIT6.s081","_id":"clrj0ullg000qfbsb9ki56hdl"},{"name":"操作系统","_id":"clrj0ullg000rfbsbh772evkk"},{"name":"虚拟内存","_id":"clrj0ullg000sfbsb1fnzf783"},{"name":"File System","_id":"clrj0ullg000zfbsb8677fj4e"},{"name":"周报","_id":"clrj0ullg0012fbsb36ck1548"},{"name":"闲聊","_id":"clrj0ullg0015fbsb2p7m9m5w"},{"name":"编译","_id":"clrj0ullg001bfbsb0iz5h6py"}],"abbrlink":[]}}